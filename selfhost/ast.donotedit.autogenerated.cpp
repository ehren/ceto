
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <map>
;
#include <typeinfo>
;
#include <numeric>
;
#include <pybind11/pybind11.h>
;
#include <pybind11/stl.h>
;
#include <pybind11/stl_bind.h>
;
#include <pybind11/functional.h>
;
#include "ast.donotedit.autogenerated.h"
;
#include "scope.donotedit.autogenerated.h"
;
#include "evalable_repr.donotedit.autogenerated.h"
;
#include "parser.donotedit.autogenerated.h"
;
#include "macro_expansion.donotedit.autogenerated.h"
;
// unsafe;
namespace py = pybind11;
    inline auto module_path() -> auto {
        const py::object module = py::module::import("ceto"); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(py::module::import("ceto")), std::remove_cvref_t<decltype(module)>>);
        const py::object os = py::module::import("os"); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(py::module::import("os")), std::remove_cvref_t<decltype(os)>>);
        const auto exeloc = (*ceto::mad(module)).attr("__file__");
        const auto dir = (*ceto::mad((*ceto::mad(os)).attr("path"))).attr(exeloc);
        return (*ceto::mad(dir)).cast<std::string>();
    }

PYBIND11_DECLARE_HOLDER_TYPE(T, ceto::propagate_const<std::shared_ptr<T>>);

PYBIND11_MODULE(_abstractsyntaxtree, m) {
;
[]( auto &&  m) {
        using namespace pybind11::literals;
        (*ceto::mad((*ceto::mad(py::class_<Source,ceto::propagate_const<std::shared_ptr<Source>>>(m, "Source"))).def(py::init<>()))).def_readwrite("source", (&Source::source));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<SourceLoc>(m, "SourceLoc"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Source>>,int>(), py::arg("source") = nullptr, py::arg("loc") = 0))).def_readwrite("source", (&SourceLoc::source)))).def_readwrite("loc", (&SourceLoc::loc)))).def_readwrite("header_file_cth", (&SourceLoc::header_file_cth)))).def_readwrite("header_file_h", (&SourceLoc::header_file_h));
        auto node { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<Node,ceto::propagate_const<std::shared_ptr<Node>>>(m, "Node"))).def_readwrite("func", (&Node::func)))).def_readwrite("args", (&Node::args)))).def_readwrite("declared_type", (&Node::declared_type)))).def_readwrite("scope", (&Node::scope)))).def_readwrite("source", (&Node::source)))).def("clone", (&Node::clone)))).def("__repr__", (&Node::repr)))).def("ast_repr", [](const Node&  n, const bool  preserve_source_loc, const bool  ceto_evalable) {
                auto vis { EvalableAstReprVisitor{preserve_source_loc, ceto_evalable} } ;
                (*ceto::mad(n)).accept(vis);
                if constexpr (!std::is_void_v<decltype((*ceto::mad(vis)).repr)>) { return (*ceto::mad(vis)).repr; } else { static_cast<void>((*ceto::mad(vis)).repr); };
                }, py::arg("preserve_source_loc") = true, py::arg("ceto_evalable") = false))).def_property_readonly("name", (&Node::name)))).def_property("parent", (&Node::parent), (&Node::set_parent)) } ;
        (*ceto::mad((*ceto::mad(py::class_<UnOp,ceto::propagate_const<std::shared_ptr<UnOp>>>(m, "UnOp", node))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&UnOp::op));
        (*ceto::mad((*ceto::mad(py::class_<LeftAssociativeUnOp,ceto::propagate_const<std::shared_ptr<LeftAssociativeUnOp>>>(m, "LeftAssociativeUnOp", node))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&LeftAssociativeUnOp::op));
        auto binop { py::class_<BinOp,ceto::propagate_const<std::shared_ptr<BinOp>>>(m, "BinOp", node) } ;
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(binop)).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("op", (&BinOp::op)))).def_property_readonly("lhs", (&BinOp::lhs)))).def_property_readonly("rhs", (&BinOp::rhs));
        auto typeop { py::class_<TypeOp,ceto::propagate_const<std::shared_ptr<TypeOp>>>(m, "TypeOp", binop) } ;
        (*ceto::mad(typeop)).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<SyntaxTypeOp,ceto::propagate_const<std::shared_ptr<SyntaxTypeOp>>>(m, "SyntaxTypeOp", typeop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("synthetic_lambda_return_lambda", (&SyntaxTypeOp::synthetic_lambda_return_lambda));
        (*ceto::mad(py::class_<AttributeAccess,ceto::propagate_const<std::shared_ptr<AttributeAccess>>>(m, "AttributeAccess", binop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<ArrowOp,ceto::propagate_const<std::shared_ptr<ArrowOp>>>(m, "ArrowOp", binop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<ScopeResolution,ceto::propagate_const<std::shared_ptr<ScopeResolution>>>(m, "ScopeResolution", binop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BitwiseOrOp,ceto::propagate_const<std::shared_ptr<BitwiseOrOp>>>(m, "BitwiseOrOp", binop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<EqualsCompareOp,ceto::propagate_const<std::shared_ptr<EqualsCompareOp>>>(m, "EqualsCompareOp", binop))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        auto assign { py::class_<Assign,ceto::propagate_const<std::shared_ptr<Assign>>>(m, "Assign", binop) } ;
        (*ceto::mad(assign)).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<NamedParameter,ceto::propagate_const<std::shared_ptr<NamedParameter>>>(m, "NamedParameter", assign))).def(py::init<const std::string &,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("op"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<Call,ceto::propagate_const<std::shared_ptr<Call>>>(m, "Call", node))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("is_one_liner_if", (&Call::is_one_liner_if));
        (*ceto::mad(py::class_<ArrayAccess,ceto::propagate_const<std::shared_ptr<ArrayAccess>>>(m, "ArrayAccess", node))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BracedCall,ceto::propagate_const<std::shared_ptr<BracedCall>>>(m, "BracedCall", node))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<Template,ceto::propagate_const<std::shared_ptr<Template>>>(m, "Template", node))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("func"), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<Identifier,ceto::propagate_const<std::shared_ptr<Identifier>>>(m, "Identifier", node))).def(py::init<const std::string &,const SourceLoc &>(), py::arg("name"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<StringLiteral,ceto::propagate_const<std::shared_ptr<StringLiteral>>>(m, "StringLiteral", node))).def(py::init<const std::string &,ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Identifier>>,const SourceLoc &>(), py::arg("str"), py::arg("prefix"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("str", (&StringLiteral::str)))).def_readwrite("prefix", (&StringLiteral::prefix)))).def_readwrite("suffix", (&StringLiteral::suffix)))).def("escaped", (&StringLiteral::escaped));
        (*ceto::mad((*ceto::mad((*ceto::mad(py::class_<IntegerLiteral,ceto::propagate_const<std::shared_ptr<IntegerLiteral>>>(m, "IntegerLiteral", node))).def(py::init<const std::string &,ceto::propagate_const<std::shared_ptr<const Identifier>>,const SourceLoc &>(), py::arg("integer_string"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("integer_string", (&IntegerLiteral::integer_string)))).def_readonly("suffix", (&IntegerLiteral::suffix));
        (*ceto::mad((*ceto::mad((*ceto::mad(py::class_<FloatLiteral,ceto::propagate_const<std::shared_ptr<FloatLiteral>>>(m, "FloatLiteral", node))).def(py::init<const std::string &,ceto::propagate_const<std::shared_ptr<const Identifier>>,const SourceLoc &>(), py::arg("float_string"), py::arg("suffix"), py::arg("source") = SourceLoc()))).def_readonly("float_string", (&FloatLiteral::float_string)))).def_readonly("suffix", (&FloatLiteral::suffix));
        auto list_like { py::class_<ListLike_,ceto::propagate_const<std::shared_ptr<ListLike_>>>(m, "ListLike_", node) } ;
        (*ceto::mad(py::class_<ListLiteral,ceto::propagate_const<std::shared_ptr<ListLiteral>>>(m, "ListLiteral", list_like))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<TupleLiteral,ceto::propagate_const<std::shared_ptr<TupleLiteral>>>(m, "TupleLiteral", list_like))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<BracedLiteral,ceto::propagate_const<std::shared_ptr<BracedLiteral>>>(m, "BracedLiteral", list_like))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        auto block { py::class_<Block,ceto::propagate_const<std::shared_ptr<Block>>>(m, "Block", list_like) } ;
        (*ceto::mad(block)).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad((*ceto::mad(py::class_<Module,ceto::propagate_const<std::shared_ptr<Module>>>(m, "Module", block))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc()))).def_readwrite("has_main_function", (&Module::has_main_function));
        (*ceto::mad(py::class_<RedundantParens,ceto::propagate_const<std::shared_ptr<RedundantParens>>>(m, "RedundantParens", node))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        (*ceto::mad(py::class_<InfixWrapper_,ceto::propagate_const<std::shared_ptr<InfixWrapper_>>>(m, "InfixWrapper_", node))).def(py::init<const std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> &,const SourceLoc &>(), py::arg("args"), py::arg("source") = SourceLoc());
        auto class_def { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<ClassDefinition,ceto::propagate_const<std::shared_ptr<ClassDefinition>>>(m, "ClassDefinition"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Call>>,bool,bool,bool>(), py::arg("name_node"), py::arg("class_def_node"), py::arg("is_unique"), py::arg("is_struct"), py::arg("is_forward_declaration")))).def_readwrite("name_node", (&ClassDefinition::name_node)))).def_readwrite("class_def_node", (&ClassDefinition::class_def_node)))).def_readwrite("is_unique", (&ClassDefinition::is_unique)))).def_readwrite("is_struct", (&ClassDefinition::is_struct)))).def_readwrite("is_forward_declaration", (&ClassDefinition::is_forward_declaration)))).def_readwrite("is_concrete", (&ClassDefinition::is_concrete)))).def_readwrite("is_pure_virtual", (&ClassDefinition::is_pure_virtual)))).def("__repr__", (&ClassDefinition::repr)) } ;
        (*ceto::mad(py::class_<InterfaceDefinition,ceto::propagate_const<std::shared_ptr<InterfaceDefinition>>>(m, "InterfaceDefinition", class_def))).def(py::init<>());
        auto variable_def { (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<VariableDefinition,ceto::propagate_const<std::shared_ptr<VariableDefinition>>>(m, "VariableDefinition"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("defined_node"), py::arg("defining_node")))).def_readwrite("defined_node", (&VariableDefinition::defined_node)))).def_readwrite("defining_node", (&VariableDefinition::defining_node)))).def("__repr__", (&VariableDefinition::repr)) } ;
        (*ceto::mad(py::class_<LocalVariableDefinition,ceto::propagate_const<std::shared_ptr<LocalVariableDefinition>>>(m, "LocalVariableDefinition", variable_def))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<GlobalVariableDefinition,ceto::propagate_const<std::shared_ptr<GlobalVariableDefinition>>>(m, "GlobalVariableDefinition", variable_def))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<FieldDefinition,ceto::propagate_const<std::shared_ptr<FieldDefinition>>>(m, "FieldDefinition", variable_def))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad(py::class_<ParameterDefinition,ceto::propagate_const<std::shared_ptr<ParameterDefinition>>>(m, "ParameterDefinition", variable_def))).def(py::init<ceto::propagate_const<std::shared_ptr<const Identifier>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("defined_node"), py::arg("defining_node"));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<FunctionDefinition,ceto::propagate_const<std::shared_ptr<FunctionDefinition>>>(m, "FunctionDefinition"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Identifier>>>(), py::arg("def_node"), py::arg("function_name")))).def_readwrite("def_node", (&FunctionDefinition::def_node)))).def_readwrite("function_name", (&FunctionDefinition::function_name)))).def("__repr__", (&FunctionDefinition::repr));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<NamespaceDefinition,ceto::propagate_const<std::shared_ptr<NamespaceDefinition>>>(m, "NamespaceDefinition"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Call>>,ceto::propagate_const<std::shared_ptr<const Node>>>(), py::arg("namespace_node"), py::arg("namespace_name")))).def_readwrite("namespace_node", (&NamespaceDefinition::namespace_node)))).def_readwrite("namespace_name", (&NamespaceDefinition::namespace_name)))).def("__repr__", (&NamespaceDefinition::repr));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<Scope,ceto::propagate_const<std::shared_ptr<Scope>>>(m, "Scope"))).def(py::init<>()))).def_readwrite("indent", (&Scope::indent)))).def_readwrite("in_function_body", (&Scope::in_function_body)))).def_readwrite("in_function_param_list", (&Scope::in_function_param_list)))).def_readwrite("in_class_body", (&Scope::in_class_body)))).def_readwrite("is_unsafe", (&Scope::is_unsafe)))).def_readwrite("in_decltype", (&Scope::in_decltype)))).def("indent_str", (&Scope::indent_str)))).def("add_variable_definition", (&Scope::add_variable_definition), "defined_node"_a, "defining_node"_a))).def("add_interface_method", (&Scope::add_interface_method)))).def("add_class_definition", (&Scope::add_class_definition)))).def("add_function_definition", (&Scope::add_function_definition)))).def("lookup_class", (&Scope::lookup_class)))).def("lookup_function", (&Scope::lookup_function)))).def("find_defs", (&Scope::find_defs), py::arg("var_node"), py::arg("find_all") = true))).def("find_def", (&Scope::find_def)))).def("enter_scope", (&Scope::enter_scope)))).def_property_readonly("parent", (&Scope::parent));
        (*ceto::mad(m)).def("creates_new_variable_scope", (&creates_new_variable_scope));
        (*ceto::mad(m)).def("comes_before", (&comes_before));
        (*ceto::mad(m)).def("parse_test", (&parse_test));
        (*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad((*ceto::mad(py::class_<MacroDefinition,ceto::propagate_const<std::shared_ptr<MacroDefinition>>>(m, "MacroDefinition"))).def(py::init<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>,std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>>()))).def_readonly("defmacro_node", (&MacroDefinition::defmacro_node)))).def_readonly("pattern_node", (&MacroDefinition::pattern_node)))).def_readonly("parameters", (&MacroDefinition::parameters)))).def_readwrite("dll_path", (&MacroDefinition::dll_path)))).def_readwrite("impl_function_name", (&MacroDefinition::impl_function_name));
        (*ceto::mad(m)).def("macro_matches", (&macro_matches));
        (*ceto::mad(m)).def("expand_macros", (&expand_macros));
        return;
        }(m);
};
