#pragma once

#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <map>
;
#include <unordered_map>
;
#include <ranges>
;
#include <functional>
;
#include <span>
;
#include <variant>
;

;
#include "ast.donotedit.autogenerated.h"
;
#include "visitor.donotedit.autogenerated.h"
;
#include "range_utility.donotedit.autogenerated.h"
;
// unsafe;
#if _MSC_VER
    #include <windows.h>
;
    
    #define CETO_DLSYM GetProcAddress
    #define CETO_DLOPEN LoadLibraryA
    #define CETO_DLCLOSE FreeLibrary
    ;
#else
    #include <dlfcn.h>
;
    
    #define CETO_DLSYM dlsym
    #define CETO_DLOPEN(L) dlopen(L, RTLD_NOW)
    #define CETO_DLCLOSE dlclose
    ;
#endif

struct SemanticAnalysisError : public std::runtime_error {

using std::runtime_error::runtime_error;

};

struct MacroDefinition : public ceto::shared_object, public std::enable_shared_from_this<MacroDefinition> {

    ceto::propagate_const<std::shared_ptr<const Node>> defmacro_node;

    ceto::propagate_const<std::shared_ptr<const Node>> pattern_node;

    std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> parameters;

    std::string dll_path = {};

    std::string impl_function_name = {};

    explicit MacroDefinition(ceto::propagate_const<std::shared_ptr<const Node>> defmacro_node, ceto::propagate_const<std::shared_ptr<const Node>> pattern_node, std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> parameters) : defmacro_node(std::move(defmacro_node)), pattern_node(std::move(pattern_node)), parameters(parameters) {}

    MacroDefinition() = delete;

};

struct MacroScope : public ceto::object {

    MacroScope const * parent = nullptr; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(nullptr), std::remove_cvref_t<decltype(parent)>>);

    std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>> macro_definitions = std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>>{}), std::remove_cvref_t<decltype(macro_definitions)>>);

        inline auto add_definition(const ceto::propagate_const<std::shared_ptr<const MacroDefinition>>&  defn) -> void {
            (*ceto::mad(this -> macro_definitions)).push_back(defn);
        }

        inline auto enter_scope() const -> ceto::propagate_const<std::unique_ptr<MacroScope>> {
            auto s = ceto::make_unique_propagate_const<MacroScope>();
            (*ceto::mad(s)).parent = this;
            return s;
        }

};

    template <typename ceto__private__T1332>
auto debug_match(const ceto__private__T1332& m) -> void {
        for(  const auto& [k, v] : std::ranges::subrange((*ceto::mad(m)).begin(), (*ceto::mad(m)).end())) {
            std::cout << "k" << k << "v" << (*ceto::mad(v)).repr();
        }
    }

    inline auto is_optional_pattern(const ceto::propagate_const<std::shared_ptr<const Node>>&  pattern,  const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  params) -> auto {
        if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(pattern)) != nullptr)) {
            return false;
        }
        const auto patt_param_it = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(pattern)).name())).value());
        if (patt_param_it != (*ceto::mad(params)).end()) {
            const auto patt_param = (patt_param_it -> second);
            if ((std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(patt_param)) != nullptr)) {
                auto rhs { ceto::bounds_check((*ceto::mad(patt_param)).args, 1) } ;
                auto is_alternational { false } ;
                while (const auto r = ceto::propagate_const<std::shared_ptr<const BitwiseOrOp>>(std::dynamic_pointer_cast<const BitwiseOrOp>(ceto::get_underlying(rhs)))) {                    is_alternational = true;
                    rhs = (*ceto::mad(r)).rhs();
                }
                if (is_alternational && ((*ceto::mad(rhs)).name() == "None")) {
                    std::cout << "isopt t\n";
                    return true;
                }
            }
        }
        std::cout << "isopt f\n";
        return false;
    }

    template <typename ceto__private__T1333, typename ceto__private__T2334>
auto macro_matches_args(const ceto__private__T1333& args, const ceto__private__T2334& pattern_args,  const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  params, const decltype(false) is_reversed = false) -> std::optional<std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>> {
        auto pattern_iterator { (*ceto::mad(pattern_args)).begin() } ;
        auto arg_iterator { (*ceto::mad(args)).begin() } ;
        auto submatches { std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{} } ;
        while (true) {            if (pattern_iterator == (*ceto::mad(pattern_args)).end()) {
                if (arg_iterator != (*ceto::mad(args)).end()) {
                    return {};
                } else {
                    break;
                }
            }
            auto subpattern { (*pattern_iterator) } ;
            if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(subpattern)) != nullptr)) {
                const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(subpattern)).name())).value());
                if (search != (*ceto::mad(params)).end()) {
                    const auto param_name = (search -> first);
                    const auto matched_param = (search -> second);
                    if (const auto type_match = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(matched_param)))) {
                        if (const auto list_param = ceto::propagate_const<std::shared_ptr<const ListLiteral>>(std::dynamic_pointer_cast<const ListLiteral>(ceto::get_underlying((*ceto::mad(type_match)).rhs())))) {
                            if ((*ceto::mad((*ceto::mad(list_param)).args)).size() != 1) {
                                throw SemanticAnalysisError{"bad ListLiteral args in macro param"};
                            }
                            const auto wildcard_list_type = ceto::bounds_check((*ceto::mad(list_param)).args, 0);
                            if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(wildcard_list_type)) != nullptr)) {
                                throw SemanticAnalysisError{"bad ListLiteral arg type in macro param"};
                            }
                            const auto wildcard_list_name = (*ceto::mad(type_match)).lhs();
                            if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(wildcard_list_name)) != nullptr)) {
                                throw SemanticAnalysisError{"arg of type ListLiteral must be an identifier"};
                            }
                            const auto wildcard_type_op = ceto::make_shared_propagate_const<const TypeOp>(":", std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{wildcard_list_name, wildcard_list_type});
                            const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> wildcard_list_params = {{(*ceto::mad_smartptr((*ceto::mad(wildcard_list_name)).name())).value(), wildcard_type_op}};
                            std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> wildcard_list_matches = std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}), std::remove_cvref_t<decltype(wildcard_list_matches)>>);
                            while (arg_iterator != (*ceto::mad(args)).end()) {                                const auto arg = (*arg_iterator);
                                if (macro_matches(arg, wildcard_list_name, wildcard_list_params)) {
                                    (wildcard_list_matches).push_back(arg);
                                } else {
                                    break;
                                }
                                arg_iterator += 1;
                            }
                            if (is_reversed) {
                                std::reverse((*ceto::mad(wildcard_list_matches)).begin(), (*ceto::mad(wildcard_list_matches)).end());
                            }
                            ceto::bounds_check(submatches, param_name) = ceto::make_shared_propagate_const<const ListLiteral>(wildcard_list_matches);
                            pattern_iterator += 1;
                            if (pattern_iterator == (*ceto::mad(pattern_args)).end()) {
                                if (arg_iterator != (*ceto::mad(args)).end()) {
                                    return {};
                                }
                                break;
                            }
                        }
                    }
                }
            }
            if (arg_iterator == (*ceto::mad(args)).end()) {
                while (pattern_iterator != (*ceto::mad(pattern_args)).end()) {                    if (!is_optional_pattern((*pattern_iterator), params)) {
                        return {};
                    }
                    pattern_iterator += 1;
                }
                return submatches;
            }
            const auto arg = (*arg_iterator);
            const auto m = macro_matches(arg, subpattern, params);
            if (m) {
                (*ceto::mad(submatches)).insert((*ceto::mad(m)).begin(), (*ceto::mad(m)).end());
            } else {
                if (!is_optional_pattern(subpattern, params)) {
                    return {};
                }
            }
            arg_iterator += 1;
            pattern_iterator += 1;
        }
        return submatches;
    }

    inline auto macro_matches(const ceto::propagate_const<std::shared_ptr<const Node>>&  node, const ceto::propagate_const<std::shared_ptr<const Node>>&  pattern,  const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  params) -> std::optional<std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>> {
        if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(pattern)) != nullptr)) {
            const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(pattern)).name())).value());
            if (search != (*ceto::mad(params)).end()) {
                const auto param_name = (search -> first);
                const auto matched_param = (search -> second);
                if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(matched_param)) != nullptr)) {
                    return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{{param_name, node}};
                } else if (const auto typeop = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(matched_param)))) {
                    const auto param_type = (*ceto::mad(typeop)).rhs();
                    if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(param_type)) != nullptr)) {
                        if ((((*ceto::mad(param_type)).name() == "BinOp") && (std::dynamic_pointer_cast<const BinOp>(ceto::get_underlying(node)) != nullptr)) || (((*ceto::mad(param_type)).name() == "UnOp") && (std::dynamic_pointer_cast<const UnOp>(ceto::get_underlying(node)) != nullptr)) || ((*ceto::mad(param_type)).name() == "Node") || ((*ceto::mad(node)).classname() == (*ceto::mad((*ceto::mad(typeop)).rhs())).name())) {
                            return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{{param_name, node}};
                        }
                    } else if (const auto or_type = ceto::propagate_const<std::shared_ptr<const BitwiseOrOp>>(std::dynamic_pointer_cast<const BitwiseOrOp>(ceto::get_underlying(param_type)))) {
                        const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> lhs_alternate_param = {{param_name, ceto::make_shared_propagate_const<const TypeOp>(":", std::vector {{matched_param, (*ceto::mad(or_type)).lhs()}})}};
                        if (const auto m = macro_matches(node, pattern, lhs_alternate_param)) {
                            return m;
                        }
                        const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> rhs_alternate_param = {{param_name, ceto::make_shared_propagate_const<const TypeOp>(":", std::vector {{matched_param, (*ceto::mad(or_type)).rhs()}})}};
                        if (const auto m = macro_matches(node, pattern, rhs_alternate_param)) {
                            return m;
                        }
                    }
                }
            }
        } else if (const auto binop_pattern = ceto::propagate_const<std::shared_ptr<const BinOp>>(std::dynamic_pointer_cast<const BinOp>(ceto::get_underlying(pattern)))) {
            std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> idents = std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}), std::remove_cvref_t<decltype(idents)>>);
            
                auto&& ceto__private__intermediate335 = (*ceto::mad(binop_pattern)).args;

                static_assert(requires { std::begin(ceto__private__intermediate335) + 2; }, "not a contiguous container");
                size_t ceto__private__size337 = std::size(ceto__private__intermediate335);
                for (size_t ceto__private__idx336 = 0; ; ceto__private__idx336++) {
                    if (std::size(ceto__private__intermediate335) != ceto__private__size337) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx336 >= ceto__private__size337) {
                        break;
                    }
                    const auto a = ceto__private__intermediate335[ceto__private__idx336];
                                    if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(a)) != nullptr)) {
                                (idents).push_back(a);
                            }

                }
                
    
                static_assert(requires { std::begin(idents) + 2; }, "not a contiguous container");
                size_t ceto__private__size342 = std::size(idents);
                for (size_t ceto__private__idx341 = 0; ; ceto__private__idx341++) {
                    if (std::size(idents) != ceto__private__size342) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx341 >= ceto__private__size342) {
                        break;
                    }
                    const auto i = idents[ceto__private__idx341];
                                    const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(i)).name())).value());
                            if (search != (*ceto::mad(params)).end()) {
                                const auto param_name = (search -> first);
                                const auto typed_param = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(search -> second)));
                                if (!typed_param) {
                                    continue;
                                }
                                if (const auto or_param = ceto::propagate_const<std::shared_ptr<const BitwiseOrOp>>(std::dynamic_pointer_cast<const BitwiseOrOp>(ceto::get_underlying((*ceto::mad(typed_param)).rhs())))) {
                                    if (((*ceto::mad((*ceto::mad(or_param)).lhs())).name() == "None") || ((*ceto::mad((*ceto::mad(or_param)).rhs())).name() == "None")) {
                            
                                            auto&& ceto__private__intermediate338 = (*ceto::mad(binop_pattern)).args;

                                            static_assert(requires { std::begin(ceto__private__intermediate338) + 2; }, "not a contiguous container");
                                            size_t ceto__private__size340 = std::size(ceto__private__intermediate338);
                                            for (size_t ceto__private__idx339 = 0; ; ceto__private__idx339++) {
                                                if (std::size(ceto__private__intermediate338) != ceto__private__size340) {
                                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                                    std::terminate();
                                                }
                                                if (ceto__private__idx339 >= ceto__private__size340) {
                                                    break;
                                                }
                                                const auto a = ceto__private__intermediate338[ceto__private__idx339];
                                                                                if ((*ceto::mad(a)).name() != (*ceto::mad(i)).name()) {
                                                                            const auto m = macro_matches(node, a, params);
                                                                            if (m) {
                                                                                return m;
                                                                            }
                                                                        }

                                            }
                                        }
                                }
                            }

                }
            }
        if ((*ceto::mad(node)).classname() != (*ceto::mad(pattern)).classname()) {
            return {};
        }
        if (((*ceto::mad(node)).func == nullptr) != ((*ceto::mad(pattern)).func == nullptr)) {
            return {};
        }
        if (((*ceto::mad((*ceto::mad(node)).args)).size() == 0) && ((*ceto::mad(node)).func == nullptr) && ((*ceto::mad(pattern)).func == nullptr)) {
            if ((*ceto::mad(node)).equals(pattern)) {
                return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{};
            }
            return {};
        }
        auto submatches { std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{} } ;
        if ((*ceto::mad(node)).func) {
            const auto m = macro_matches((*ceto::mad(node)).func, (*ceto::mad(pattern)).func, params);
            if (!m) {
                return {};
            }
            (*ceto::mad(submatches)).insert((*ceto::mad(m)).begin(), (*ceto::mad(m)).end());
        }
        const auto left_to_right_matches = macro_matches_args((*ceto::mad(node)).args, (*ceto::mad(pattern)).args, params);
        if ((*ceto::mad((*ceto::mad(pattern)).args)).size() > 1) {
            const auto right_to_left_matches = macro_matches_args(ceto::util::reversed((*ceto::mad(node)).args), ceto::util::reversed((*ceto::mad(pattern)).args), params, true);
            if (right_to_left_matches && (!left_to_right_matches || ((*ceto::mad(left_to_right_matches)).size() < (*ceto::mad(right_to_left_matches)).size()))) {
                (*ceto::mad(submatches)).insert((*ceto::mad(right_to_left_matches)).begin(), (*ceto::mad(right_to_left_matches)).end());
                return submatches;
            }
        }
        if (!left_to_right_matches) {
            return {};
        }
        (*ceto::mad(submatches)).insert((*ceto::mad(left_to_right_matches)).begin(), (*ceto::mad(left_to_right_matches)).end());
        return submatches;
    }

    inline auto macro_matches_not_greedy_enough(const ceto::propagate_const<std::shared_ptr<const Node>>&  node, const ceto::propagate_const<std::shared_ptr<const Node>>&  pattern,  const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  params) -> std::optional<std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>> {
        std::cout << "node: " << (*ceto::mad(node)).repr() << " pattern: " << (*ceto::mad(pattern)).repr() << "\n";
        if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(pattern)) != nullptr)) {
            const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(pattern)).name())).value());
            if (search != (*ceto::mad(params)).end()) {
                const auto param_name = (search -> first);
                const auto matched_param = (search -> second);
                if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(matched_param)) != nullptr)) {
                    return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{{param_name, node}};
                } else if (const auto typeop = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(matched_param)))) {
                    const auto param_type = (*ceto::mad(typeop)).rhs();
                    if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(param_type)) != nullptr)) {
                        if ((((*ceto::mad(param_type)).name() == "BinOp") && (std::dynamic_pointer_cast<const BinOp>(ceto::get_underlying(node)) != nullptr)) || (((*ceto::mad(param_type)).name() == "UnOp") && (std::dynamic_pointer_cast<const UnOp>(ceto::get_underlying(node)) != nullptr)) || ((*ceto::mad(param_type)).name() == "Node") || ((*ceto::mad(node)).classname() == (*ceto::mad((*ceto::mad(typeop)).rhs())).name())) {
                            return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{{param_name, node}};
                        }
                    } else if (const auto or_type = ceto::propagate_const<std::shared_ptr<const BitwiseOrOp>>(std::dynamic_pointer_cast<const BitwiseOrOp>(ceto::get_underlying(param_type)))) {
                        std::cout << "\n\n\n\nor_type simple" << (*ceto::mad(or_type)).repr() << "\n\n\n\n";
                        const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> lhs_alternate_param = {{param_name, ceto::make_shared_propagate_const<const TypeOp>(":", std::vector {{matched_param, (*ceto::mad(or_type)).lhs()}})}};
                        if (const auto m = macro_matches(node, pattern, lhs_alternate_param)) {
                            std::cout << 1 << std::endl;
                            debug_match(m);
                            return m;
                        }
                        const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> rhs_alternate_param = {{param_name, ceto::make_shared_propagate_const<const TypeOp>(":", std::vector {{matched_param, (*ceto::mad(or_type)).rhs()}})}};
                        if (const auto m = macro_matches(node, pattern, rhs_alternate_param)) {
                            std::cout << 2 << std::endl;
                            return m;
                        }
                        std::cout << 3 << std::endl;
                        return {};
                    }
                }
            }
        } else if (const auto binop_pattern = ceto::propagate_const<std::shared_ptr<const BinOp>>(std::dynamic_pointer_cast<const BinOp>(ceto::get_underlying(pattern)))) {
            std::cout << "\n\n\n\nbinop_pattern" << (*ceto::mad(binop_pattern)).repr() << "\n\n\n\n";
            std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> idents = std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}), std::remove_cvref_t<decltype(idents)>>);
            
                auto&& ceto__private__intermediate343 = (*ceto::mad(binop_pattern)).args;

                static_assert(requires { std::begin(ceto__private__intermediate343) + 2; }, "not a contiguous container");
                size_t ceto__private__size345 = std::size(ceto__private__intermediate343);
                for (size_t ceto__private__idx344 = 0; ; ceto__private__idx344++) {
                    if (std::size(ceto__private__intermediate343) != ceto__private__size345) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx344 >= ceto__private__size345) {
                        break;
                    }
                    const auto a = ceto__private__intermediate343[ceto__private__idx344];
                                    if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(a)) != nullptr)) {
                                (idents).push_back(a);
                            }

                }
                
    
                static_assert(requires { std::begin(idents) + 2; }, "not a contiguous container");
                size_t ceto__private__size350 = std::size(idents);
                for (size_t ceto__private__idx349 = 0; ; ceto__private__idx349++) {
                    if (std::size(idents) != ceto__private__size350) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx349 >= ceto__private__size350) {
                        break;
                    }
                    const auto i = idents[ceto__private__idx349];
                                    const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(i)).name())).value());
                            if (search != (*ceto::mad(params)).end()) {
                                const auto param_name = (search -> first);
                                const auto typed_param = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(search -> second)));
                                if (!typed_param) {
                                    continue;
                                }
                                if (const auto or_param = ceto::propagate_const<std::shared_ptr<const BitwiseOrOp>>(std::dynamic_pointer_cast<const BitwiseOrOp>(ceto::get_underlying((*ceto::mad(typed_param)).rhs())))) {
                                    if (((*ceto::mad((*ceto::mad(or_param)).lhs())).name() == "None") || ((*ceto::mad((*ceto::mad(or_param)).rhs())).name() == "None")) {
                                        std::cout << "\n\n\n\nor_param" << (*ceto::mad(or_param)).repr() << "\n\n\n\n";
                            
                                            auto&& ceto__private__intermediate346 = (*ceto::mad(binop_pattern)).args;

                                            static_assert(requires { std::begin(ceto__private__intermediate346) + 2; }, "not a contiguous container");
                                            size_t ceto__private__size348 = std::size(ceto__private__intermediate346);
                                            for (size_t ceto__private__idx347 = 0; ; ceto__private__idx347++) {
                                                if (std::size(ceto__private__intermediate346) != ceto__private__size348) {
                                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                                    std::terminate();
                                                }
                                                if (ceto__private__idx347 >= ceto__private__size348) {
                                                    break;
                                                }
                                                const auto a = ceto__private__intermediate346[ceto__private__idx347];
                                                                                if ((*ceto::mad(a)).name() != (*ceto::mad(i)).name()) {
                                                                            const auto m = macro_matches(node, a, params);
                                                                            if (m) {
                                                                                return m;
                                                                            }
                                                                        }

                                            }
                                        }
                                }
                            }

                }
            }
        if ((*ceto::mad(node)).classname() != (*ceto::mad(pattern)).classname()) {
            return {};
        }
        if (((*ceto::mad(node)).func == nullptr) != ((*ceto::mad(pattern)).func == nullptr)) {
            return {};
        }
        if (((*ceto::mad((*ceto::mad(node)).args)).size() == 0) && ((*ceto::mad(node)).func == nullptr) && ((*ceto::mad(pattern)).func == nullptr)) {
            if ((*ceto::mad(node)).equals(pattern)) {
                return std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{};
            } else {
                return {};
            }
        }
        auto submatches { std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{} } ;
        if ((*ceto::mad(node)).func) {
            const auto m = macro_matches((*ceto::mad(node)).func, (*ceto::mad(pattern)).func, params);
            if (!m) {
                return {};
            }
            (*ceto::mad(submatches)).insert((*ceto::mad(m)).begin(), (*ceto::mad(m)).end());
        }
        auto pattern_iterator { (*ceto::mad((*ceto::mad(pattern)).args)).cbegin() } ;
        auto arg_iterator { (*ceto::mad((*ceto::mad(node)).args)).cbegin() } ;
        while (true) {            std::cout << "main loop\n";
            if (pattern_iterator == (*ceto::mad((*ceto::mad(pattern)).args)).end()) {
                if (arg_iterator != (*ceto::mad((*ceto::mad(node)).args)).end()) {
                    return {};
                } else {
                    break;
                }
            }
            auto subpattern { (*pattern_iterator) } ;
            std::cout << "subpatt " << (*ceto::mad(subpattern)).repr() << "\n";
            auto next_optional_match_success { false } ;
            if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(subpattern)) != nullptr)) {
                const auto search = (*ceto::mad(params)).find((*ceto::mad_smartptr((*ceto::mad(subpattern)).name())).value());
                if (search != (*ceto::mad(params)).end()) {
                    const auto param_name = (search -> first);
                    const auto matched_param = (search -> second);
                    if (const auto type_match = ceto::propagate_const<std::shared_ptr<const TypeOp>>(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(matched_param)))) {
                        if (const auto list_param = ceto::propagate_const<std::shared_ptr<const ListLiteral>>(std::dynamic_pointer_cast<const ListLiteral>(ceto::get_underlying((*ceto::mad(type_match)).rhs())))) {
                            if ((*ceto::mad((*ceto::mad(list_param)).args)).size() != 1) {
                                throw SemanticAnalysisError{"bad ListLiteral args in macro param"};
                            }
                            const auto wildcard_list_type = ceto::bounds_check((*ceto::mad(list_param)).args, 0);
                            if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(wildcard_list_type)) != nullptr)) {
                                throw SemanticAnalysisError{"bad ListLiteral arg type in macro param"};
                            }
                            const auto wildcard_list_name = (*ceto::mad(type_match)).lhs();
                            if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(wildcard_list_name)) != nullptr)) {
                                throw SemanticAnalysisError{"arg of type ListLiteral must be an identifier"};
                            }
                            const auto wildcard_type_op = ceto::make_shared_propagate_const<const TypeOp>(":", std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{wildcard_list_name, wildcard_list_type});
                            const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> wildcard_list_params = {{(*ceto::mad_smartptr((*ceto::mad(wildcard_list_name)).name())).value(), wildcard_type_op}};
                            std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> wildcard_list_matches = std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}), std::remove_cvref_t<decltype(wildcard_list_matches)>>);
                            const auto remaining_patterns = std::distance(pattern_iterator + 1, (*ceto::mad((*ceto::mad(pattern)).args)).end());
                            std::cout << "remain patts" << remaining_patterns << "\n";
                            while (arg_iterator != (*ceto::mad((*ceto::mad(node)).args)).end()) {                                const auto remaining_args = std::distance(arg_iterator, (*ceto::mad((*ceto::mad(node)).args)).end());
                                std::cout << "remain args" << remaining_args << "\n";
                                auto num_optional_match_fails { 0 } ;
                                next_optional_match_success = false;
                                if (remaining_patterns >= 1) {
                                    auto next_patt_it { (pattern_iterator + 1) } ;
                                    std::cout << "have remain patts\n";
                                    while (next_patt_it != (*ceto::mad((*ceto::mad(pattern)).args)).end()) {                                        std::cout << "next patt\n";
                                        const auto next_patt = (*next_patt_it);
                                        if (is_optional_pattern(next_patt, params)) {
                                            const auto arg = (*arg_iterator);
                                            const auto m = macro_matches(arg, next_patt, params);
                                            if (m) {
                                                std::cout << "succ\n";
                                                debug_match(m);
                                                debug_match(submatches);
                                                (*ceto::mad(submatches)).insert((*ceto::mad(m)).begin(), (*ceto::mad(m)).end());
                                                debug_match(submatches);
                                                arg_iterator += 1;
                                                pattern_iterator = next_patt_it;
                                                subpattern = next_patt;
                                                next_optional_match_success = true;
                                                break;
                                            } else {
                                                std::cout << "fail\n";
                                                num_optional_match_fails += 1;
                                            }
                                        }
                                        next_patt_it += 1;
                                        std::cout << "done next patt\n";
                                    }
                                }
                                std::cout << "a\n";
                                if (next_optional_match_success) {
                                    break;
                                }
                                std::cout << "b\n";
                                if ((remaining_args - num_optional_match_fails) <= remaining_patterns) {
                                    std::cout << "b.1\n";
                                    arg_iterator += 1;
                                    break;
                                }
                                std::cout << "c\n";
                                const auto arg = (*arg_iterator);
                                if (macro_matches(arg, wildcard_list_name, wildcard_list_params)) {
                                    (wildcard_list_matches).push_back(arg);
                                    arg_iterator += 1;
                                } else {
                                    break;
                                }
                            }
                            ceto::bounds_check(submatches, param_name) = ceto::make_shared_propagate_const<const ListLiteral>(wildcard_list_matches);
                            if (next_optional_match_success) {
                                break;
                            }
                            pattern_iterator += 1;
                            if (pattern_iterator == (*ceto::mad((*ceto::mad(pattern)).args)).end()) {
                                if (arg_iterator != (*ceto::mad((*ceto::mad(node)).args)).end()) {
                                    std::cout << "no match - out of patterns, still have args\n";
                                    return {};
                                }
                                std::cout << "no match - out of patterns, still have args\n";
                                break;
                            }
                            subpattern = (*pattern_iterator);
                        }
                    }
                }
            }
            std::cout << "g\n";
            debug_match(submatches);
            std::cout << [&]() {if (arg_iterator == (*ceto::mad((*ceto::mad(node)).args)).end()) {
                return "eq";
            } else {
                return "ne";
            }}()
;
            std::cout << "g2\n";
            if (arg_iterator == (*ceto::mad((*ceto::mad(node)).args)).end()) {
                std::cout << "h\n";
                while (pattern_iterator != (*ceto::mad((*ceto::mad(pattern)).args)).end()) {                    std::cout << "i\n";
                    if (!is_optional_pattern((*pattern_iterator), params)) {
                        std::cout << "j\n";
                        return {};
                    }
                    pattern_iterator += 1;
                    std::cout << "k\n";
                }
                std::cout << "k2\n";
                return submatches;
            }
            std::cout << "subpattern:";
            debug_match(submatches);
            const auto arg = (*arg_iterator);
            const auto m = macro_matches(arg, subpattern, params);
            if (m) {
                (*ceto::mad(submatches)).insert((*ceto::mad(m)).begin(), (*ceto::mad(m)).end());
                arg_iterator += 1;
            } else {
                if (!is_optional_pattern(subpattern, params)) {
                    return {};
                }
            }
            pattern_iterator += 1;
        }
        std::cout << "done\n";
        return submatches;
    }

using MacroImplResult = std::variant<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::macros::Skip>;
    inline auto call_macro_impl(const ceto::propagate_const<std::shared_ptr<const MacroDefinition>>&  definition,  const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  match) -> MacroImplResult {
        const auto handle = CETO_DLOPEN((*ceto::mad((*ceto::mad(definition)).dll_path)).c_str());
        if (!handle) {
            throw std::runtime_error("Failed to open macro dll: " + (*ceto::mad(definition)).dll_path);
        }
        const auto fptr = CETO_DLSYM(handle, (*ceto::mad((*ceto::mad(definition)).impl_function_name)).c_str());
        if (!fptr) {
            throw std::runtime_error("Failed to find symbol " + (*ceto::mad(definition)).impl_function_name + " in dll " + (*ceto::mad(definition)).dll_path);
        }
        const auto f = reinterpret_cast<decltype(+[]( const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>> &  m) -> MacroImplResult {
                return nullptr;
                })>(fptr);
        return (*f)(match);
    }

struct ExpandResult : public ceto::object {

    bool did_expand;

    ceto::propagate_const<std::shared_ptr<const Node>> _node;

    std::map<ceto::propagate_const<std::shared_ptr<const Node>>,std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>>> & _skipped_definitions;

        ~ExpandResult() {
            if (this -> did_expand) {
                return;
            }
            const auto it = (*ceto::mad(this -> _skipped_definitions)).find(this -> _node);
            if (it != (*ceto::mad(this -> _skipped_definitions)).end()) {
                (*ceto::mad(it -> second)).clear();
            }
        }

    explicit ExpandResult(bool did_expand, ceto::propagate_const<std::shared_ptr<const Node>> _node, std::map<ceto::propagate_const<std::shared_ptr<const Node>>,std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>>> & _skipped_definitions) : did_expand(did_expand), _node(std::move(_node)), _skipped_definitions(_skipped_definitions) {}

    ExpandResult() = delete;

};

struct MacroDefinitionVisitor : public BaseVisitor<MacroDefinitionVisitor> {

    std::function<void(ceto::propagate_const<std::shared_ptr<const MacroDefinition>>, const std::unordered_map<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>> &)> on_visit_definition;

    ceto::propagate_const<std::unique_ptr<MacroScope>> current_scope = nullptr; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(nullptr), std::remove_cvref_t<decltype(current_scope)>>);

    std::unordered_map<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>> replacements = {};

    std::map<ceto::propagate_const<std::shared_ptr<const Node>>,std::vector<ceto::propagate_const<std::shared_ptr<const MacroDefinition>>>> skipped_definitions = {};

        inline auto expand(const ceto::propagate_const<std::shared_ptr<const Node>>&  node) -> auto {
            auto const * scope { (&(this -> current_scope)) -> get() } ;
            while (scope) {                
                    auto&& ceto__private__intermediate351 = scope -> macro_definitions;
                auto&& ceto__private__intermediate352 = ceto::util::reversed(ceto__private__intermediate351);

                    static_assert(requires { std::begin(ceto__private__intermediate352) + 2; }, "not a contiguous container");
                    size_t ceto__private__size354 = std::size(ceto__private__intermediate352);
                    for (size_t ceto__private__idx353 = 0; ; ceto__private__idx353++) {
                        if (std::size(ceto__private__intermediate352) != ceto__private__size354) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx353 >= ceto__private__size354) {
                            break;
                        }
                        const auto definition = ceto__private__intermediate352[ceto__private__idx353];
                                            auto skip_definition { false } ;
                                    for(  const auto & [key, defns] : (this -> skipped_definitions)) {
                                        if (ceto::util::contains(defns, definition)) {
                                            skip_definition = true;
                                            break;
                                        }
                                    }
                                    if (skip_definition) {
                                        continue;
                                    }
                                    const auto match = macro_matches(node, (*ceto::mad(definition)).pattern_node, (*ceto::mad(definition)).parameters);
                                    if (match) {
                                        const auto result_variant = call_macro_impl(definition, (*ceto::mad_smartptr(match)).value());
                                        if (std::holds_alternative<ceto::macros::Skip>(result_variant)) {
                                            (*ceto::mad(ceto::bounds_check(this -> skipped_definitions, node))).push_back(definition);
                                        } else {
                                            const auto replacement = std::get<ceto::propagate_const<std::shared_ptr<const Node>>>(result_variant);
                                            if (replacement && (replacement != node)) {
                                                ceto::bounds_check(this -> replacements, node) = replacement;
                                                (*ceto::mad(replacement)).accept((*this));
                                                const auto did_expand = true;
                                                return ExpandResult{did_expand, node, this -> skipped_definitions};
                                            }
                                        }
                                    }

                    }
                    scope = (scope -> parent);
            }
            const auto did_expand = false;
            return ExpandResult{did_expand, node, this -> skipped_definitions};
        }

        inline auto visit(const Node&  n) -> void override {
            const auto node = ceto::shared_from((&n));
            const auto expand_result = this -> expand(node);
            if ((*ceto::mad(expand_result)).did_expand) {
                return;
            }
            if ((*ceto::mad(node)).func) {
                (*ceto::mad((*ceto::mad(node)).func)).accept((*this));
            }
            
                auto&& ceto__private__intermediate355 = (*ceto::mad(node)).args;

                static_assert(requires { std::begin(ceto__private__intermediate355) + 2; }, "not a contiguous container");
                size_t ceto__private__size357 = std::size(ceto__private__intermediate355);
                for (size_t ceto__private__idx356 = 0; ; ceto__private__idx356++) {
                    if (std::size(ceto__private__intermediate355) != ceto__private__size357) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx356 >= ceto__private__size357) {
                        break;
                    }
                    const auto arg = ceto__private__intermediate355[ceto__private__idx356];
                                    (*ceto::mad(arg)).accept((*this));

                }
            }

        inline auto visit(const Call&  call_node) -> void override {
            const auto node = ceto::shared_from((&call_node));
            const auto expand_result = this -> expand(node);
            if ((*ceto::mad(expand_result)).did_expand) {
                return;
            }
            (*ceto::mad((*ceto::mad(node)).func)).accept((*this));
            
                auto&& ceto__private__intermediate358 = (*ceto::mad(node)).args;

                static_assert(requires { std::begin(ceto__private__intermediate358) + 2; }, "not a contiguous container");
                size_t ceto__private__size360 = std::size(ceto__private__intermediate358);
                for (size_t ceto__private__idx359 = 0; ; ceto__private__idx359++) {
                    if (std::size(ceto__private__intermediate358) != ceto__private__size360) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx359 >= ceto__private__size360) {
                        break;
                    }
                    const auto arg = ceto__private__intermediate358[ceto__private__idx359];
                                    (*ceto::mad(arg)).accept((*this));

                }
                if ((*ceto::mad((*ceto::mad(node)).func)).name() != "defmacro") {
                return;
            }
            if (!(std::dynamic_pointer_cast<const Module>(ceto::get_underlying((*ceto::mad(node)).parent())) != nullptr)) {
                return;
            }
            if ((*ceto::mad((*ceto::mad(node)).args)).size() < 2) {
                throw SemanticAnalysisError{"bad defmacro args"};
            }
            const auto pattern = ceto::bounds_check((*ceto::mad(node)).args, 0);
            if (!(std::dynamic_pointer_cast<const Block>(ceto::get_underlying((*ceto::mad((*ceto::mad(node)).args)).back())) != nullptr)) {
                throw SemanticAnalysisError{"last defmacro arg must be a Block"};
            }
            auto parameters { std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>{} } ;
            #if defined(__clang__) && (__clang_major__ < 16)
                const auto match_args = std::vector((*ceto::mad((*ceto::mad(node)).args)).cbegin() + 1, (*ceto::mad((*ceto::mad(node)).args)).cend() - 1);
            #else
                const auto match_args = std::span((*ceto::mad((*ceto::mad(node)).args)).cbegin() + 1, (*ceto::mad((*ceto::mad(node)).args)).cend() - 1);
            #endif

            
    
                static_assert(requires { std::begin(match_args) + 2; }, "not a contiguous container");
                size_t ceto__private__size362 = std::size(match_args);
                for (size_t ceto__private__idx361 = 0; ; ceto__private__idx361++) {
                    if (std::size(match_args) != ceto__private__size362) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx361 >= ceto__private__size362) {
                        break;
                    }
                    const auto arg = match_args[ceto__private__idx361];
                                    const auto name = [&]() {if ((std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(arg)) != nullptr)) {
                                return (*ceto::mad_smartptr((*ceto::mad(arg)).name())).value();
                            } else if (!(std::dynamic_pointer_cast<const TypeOp>(ceto::get_underlying(arg)) != nullptr)) {
                                throw SemanticAnalysisError{"bad defmacro param type"};
                            } else if (!(std::dynamic_pointer_cast<const Identifier>(ceto::get_underlying(ceto::bounds_check((*ceto::mad(arg)).args, 0))) != nullptr)) {
                                throw SemanticAnalysisError{"bad typed defmacro param"};
                            } else {
                                return (*ceto::mad_smartptr((*ceto::mad(ceto::bounds_check((*ceto::mad(arg)).args, 0))).name())).value();
                            }}()
            ;
                            const auto i = (*ceto::mad(parameters)).find(name);
                            if (i != (*ceto::mad(parameters)).end()) {
                                throw SemanticAnalysisError{"duplicate defmacro params"};
                            }
                            (*ceto::mad_smartptr(parameters)).emplace(name, arg);

                }
                const auto defn = ceto::make_shared_propagate_const<const MacroDefinition>(node, pattern, parameters);
            (*ceto::mad(this -> current_scope)).add_definition(defn);
            this -> on_visit_definition(defn, this -> replacements);
        }

        inline auto visit(const Module&  node) -> void override {
            auto s = ceto::make_unique_propagate_const<MacroScope>();
            (this -> current_scope) = std::move(s);
            
                auto&& ceto__private__intermediate363 = (*ceto::mad(node)).args;

                static_assert(requires { std::begin(ceto__private__intermediate363) + 2; }, "not a contiguous container");
                size_t ceto__private__size365 = std::size(ceto__private__intermediate363);
                for (size_t ceto__private__idx364 = 0; ; ceto__private__idx364++) {
                    if (std::size(ceto__private__intermediate363) != ceto__private__size365) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx364 >= ceto__private__size365) {
                        break;
                    }
                    const auto arg = ceto__private__intermediate363[ceto__private__idx364];
                                    (*ceto::mad(arg)).accept((*this));

                }
            }

        inline auto visit(const Block&  block_node) -> void override {
            ceto::propagate_const<std::unique_ptr<MacroScope>> outer = std::move(this -> current_scope); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::move(this -> current_scope)), std::remove_cvref_t<decltype(outer)>>);
            (this -> current_scope) = (*ceto::mad(outer)).enter_scope();
            const auto node = ceto::shared_from((&block_node));
            const auto expand_result = this -> expand(node);
            if ((*ceto::mad(expand_result)).did_expand) {
                return;
            }
            
                auto&& ceto__private__intermediate366 = (*ceto::mad(node)).args;

                static_assert(requires { std::begin(ceto__private__intermediate366) + 2; }, "not a contiguous container");
                size_t ceto__private__size368 = std::size(ceto__private__intermediate366);
                for (size_t ceto__private__idx367 = 0; ; ceto__private__idx367++) {
                    if (std::size(ceto__private__intermediate366) != ceto__private__size368) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx367 >= ceto__private__size368) {
                        break;
                    }
                    const auto arg = ceto__private__intermediate366[ceto__private__idx367];
                                    (*ceto::mad(arg)).accept((*this));

                }
                (this -> current_scope) = std::move(outer);
        }

    explicit MacroDefinitionVisitor(std::function<void(ceto::propagate_const<std::shared_ptr<const MacroDefinition>>, const std::unordered_map<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>> &)> on_visit_definition) : on_visit_definition(on_visit_definition) {}

    MacroDefinitionVisitor() = delete;

};

    inline auto expand_macros(const ceto::propagate_const<std::shared_ptr<const Module>>&  node, const std::function<void(ceto::propagate_const<std::shared_ptr<const MacroDefinition>>, const std::unordered_map<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>> &)>  on_visit) -> std::unordered_map<ceto::propagate_const<std::shared_ptr<const Node>>,ceto::propagate_const<std::shared_ptr<const Node>>> {
        auto visitor { MacroDefinitionVisitor{on_visit} } ;
        (*ceto::mad(node)).accept(visitor);
        return (*ceto::mad(visitor)).replacements;
    }

