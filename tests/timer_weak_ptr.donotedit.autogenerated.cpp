
#include "ceto.h"

;

;

;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <thread>
;
struct Delegate : public ceto::shared_object, public std::enable_shared_from_this<Delegate> {

        inline auto action() const -> void {
            std::cout << "action\n";
        }

        ~Delegate() {
            std::cout << "Delegate destruct\n";
        }

};

 // unsafe external C++: std.thread, std.this_thread
;
struct Timer : public ceto::shared_object, public std::enable_shared_from_this<Timer> {

    ceto::propagate_const<std::shared_ptr<const Delegate>> _delegate;

    std::thread _thread = {};

        inline auto start() -> void {
            const std::weak_ptr<const Delegate> w = ceto::get_underlying((this -> _delegate)); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(ceto::get_underlying((this -> _delegate))), std::remove_cvref_t<decltype(w)>>);
            (this -> _thread) = std::thread([w = ceto::default_capture(w)]() {
                    while (true) {                        std::this_thread::sleep_for(std::chrono::seconds(1));
                        if (const auto s = (*ceto::mad(w)).lock()) {
                            (*ceto::mad(s)).action();
                        } else {
                            break;
                        }
                    }
                    return;
                    });
        }

        inline auto join() -> void {
            (*ceto::mad(this -> _thread)).join();
        }

        inline auto clear_delegate() -> void {
            (this -> _delegate) = nullptr;
        }

        ~Timer() {
            std::cout << "Timer destruct\n";
        }

    explicit Timer(ceto::propagate_const<std::shared_ptr<const Delegate>> _delegate) : _delegate(std::move(_delegate)) {}

    Timer() = delete;

};

    auto main() -> int {
        auto timer { ceto::make_shared_propagate_const<Timer>(ceto::make_shared_propagate_const<const Delegate>()) } ;
        (*ceto::mad(timer)).start();
        using namespace std::literals;
        std::this_thread::sleep_for(3.5s);
        (*ceto::mad(timer)).clear_delegate();
        (*ceto::mad(timer)).join();
    }

