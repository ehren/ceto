
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
struct Blah1 : public ceto::shared_object, public std::enable_shared_from_this<Blah1> {

         interface(A) inline auto foo(const A  x) const -> int {
            printf("Blah1 foo\n");
            return (*ceto::mad(x)).huh();
        }

         interface(A) inline auto huh() const -> int {
            printf("huh 1\n");
            return 76;
        }

};

struct Blah2 : public ceto::shared_object, public std::enable_shared_from_this<Blah2> {

         interface(A) inline auto foo(const A  x) const -> int {
            printf("Blah2 foo\n");
            return (*ceto::mad(x)).huh();
        }

         interface(A) inline auto huh() const -> int {
            printf("huh 2\n");
            return 89;
        }

};

    auto main() -> int {
        const auto a = ceto::make_shared_propagate_const<const Blah1>();
        const auto b = ceto::make_shared_propagate_const<const Blah2>();
        const auto l = std::vector<A>{a, b};
        (*ceto::mad(ceto::bounds_check(l, 0))).foo([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(l, 1))> ) && true)); return ceto::bounds_check(l, 1); }());
        (*ceto::mad(ceto::bounds_check(l, 1))).foo([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(l, 0))> ) && true)); return ceto::bounds_check(l, 0); }());
    }

