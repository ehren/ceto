
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
    template <typename T1>
auto stuff(const T1& a) -> auto {
        return ceto::bounds_check(a, 0);
    }

    template <typename T1, typename T2, typename T3>
auto takes_func_arg_arg(const T1& func, const T2& arg1, const T3& arg2) -> auto {
        return func(arg1, arg2);
    }

    template <typename T1>
auto foo(const T1& x) -> auto {
        return (x + 1);
    }

    auto main() -> int {
        auto x { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<decltype(1)>>(), 1))>>() } ;
        const auto zz = std::vector {{1, 2, 3}};
        const auto xx = std::vector {{std::vector {{1, 2}}, std::vector {{2, 3}}}};
        auto xx2 { std::vector<std::vector<std::vector<int>>>() } ;
        auto xx3 { std::vector<std::vector<std::vector<decltype(1)>>>() } ;
        const auto xxanother = xx;
        std::vector<std::vector<int>> xxanother2 = xxanother; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(xxanother), std::remove_cvref_t<decltype(xxanother2)>>);
        auto xxanother3 { xxanother } ;
        (xx2).push_back(xxanother2);
        (xx3).push_back(xxanother3);
        ceto::bounds_check(xxanother2, 0) = std::vector {{7, 7, 7}};
        ceto::bounds_check(xxanother3, 1) = std::vector {{8, 7, 6}};
        printf("xxanother2 %d\n", [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(ceto::bounds_check(xxanother2, 0), 0))>  || (!std::is_reference_v<decltype("xxanother2 %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("xxanother2 %d\n")>>)) && true)); return ceto::bounds_check(ceto::bounds_check(xxanother2, 0), 0); }());
        printf("xxanother %d\n", [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(ceto::bounds_check(xxanother, 0), 0))>  || (!std::is_reference_v<decltype("xxanother %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("xxanother %d\n")>>)) && true)); return ceto::bounds_check(ceto::bounds_check(xxanother, 0), 0); }());
        const auto lfunc = [](const auto &x, const auto &y) {
                return (x + y);
                };
        const auto lfunc2 = [](const auto &x, const auto &y) {
                printf("x %d y %d\n", x, y);
                return (x + y);
                };
        const auto huh = takes_func_arg_arg(lfunc2, 14, 15);
        printf("yo:\n            %d %d\n", [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(ceto::bounds_check(ceto::bounds_check(xx3, 0), 0), 0))>  || (!std::is_reference_v<decltype("yo:\n            %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("yo:\n            %d %d\n")>> && !std::is_reference_v<decltype(huh)> && std::is_fundamental_v<std::remove_cvref_t<decltype(huh)>>)) && true)); return ceto::bounds_check(ceto::bounds_check(ceto::bounds_check(xx3, 0), 0), 0); }(), huh);
        const auto z = 5;
        const auto w = z;
        const auto q = foo(w + 1);
        if (1) {
            (x).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(zz, 1))> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(x)>>)); return ceto::bounds_check(zz, 1); }());
        } else if ((z == 4)) {
            if (q == 6) {
                static_cast<void>(1);
            } else {
                static_cast<void>(10);
            }
        } else {
            (x).push_back(foo(w - 1));
        }
        printf("ohsnap\n%d", [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(x, 0))>  || (!std::is_reference_v<decltype("ohsnap\n%d")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap\n%d")>>)) && true)); return ceto::bounds_check(x, 0); }());
        const auto yy = std::vector {{ceto::bounds_check(x, 0), foo(ceto::bounds_check(x, 0))}};
        const auto y = std::vector {{ceto::bounds_check(x, 0), foo(w), w + 25}};
        printf("ohsnap2 %d %d %d\n", stuff(y), [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(y, 1))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(yy, 0))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype(ceto::bounds_check(y, 1))> && std::is_fundamental_v<std::remove_cvref_t<decltype(ceto::bounds_check(y, 1))>>)) && true)); return ceto::bounds_check(yy, 0); }())> && std::is_fundamental_v<std::remove_cvref_t<decltype([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(yy, 0))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype(ceto::bounds_check(y, 1))> && std::is_fundamental_v<std::remove_cvref_t<decltype(ceto::bounds_check(y, 1))>>)) && true)); return ceto::bounds_check(yy, 0); }())>>)) && true)); return ceto::bounds_check(y, 1); }(), [&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(yy, 0))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(y, 1))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype(ceto::bounds_check(yy, 0))> && std::is_fundamental_v<std::remove_cvref_t<decltype(ceto::bounds_check(yy, 0))>>)) && true)); return ceto::bounds_check(y, 1); }())> && std::is_fundamental_v<std::remove_cvref_t<decltype([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check(y, 1))>  || (!std::is_reference_v<decltype("ohsnap2 %d %d %d\n")> && std::is_fundamental_v<std::remove_cvref_t<decltype("ohsnap2 %d %d %d\n")>> && !std::is_reference_v<decltype(stuff(y))> && std::is_fundamental_v<std::remove_cvref_t<decltype(stuff(y))>> && !std::is_reference_v<decltype(ceto::bounds_check(yy, 0))> && std::is_fundamental_v<std::remove_cvref_t<decltype(ceto::bounds_check(yy, 0))>>)) && true)); return ceto::bounds_check(y, 1); }())>>)) && true)); return ceto::bounds_check(yy, 0); }());
        return 0;
    }

