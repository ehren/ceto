
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
// unsafe;
    template <typename T1, typename T2>
auto bar(const T1& x, const T2& y) -> void {
        ; // pass
    }

struct Foo : public ceto::shared_object, public std::enable_shared_from_this<Foo> {

    decltype(std::vector {{1, 2, 3}}) a = std::vector {{1, 2, 3}};

    decltype(std::vector {{4, 5, 6}}) b = std::vector {{4, 5, 6}};

        inline auto blah() -> void {
            ceto::append_or_push_back(this -> a, 1);
            ceto::append_or_push_back(this -> b, 2);
        }

        inline auto foo() -> void {
            (*ceto::mad(this -> a)).begin();
            if (1) {
                // unsafe;
                (*ceto::mad(this -> a)).begin();
            }
            (*[&]() {if (1) {
                // unsafe;
                return (*ceto::mad(this -> a)).begin();
            }}()
);
            
                auto&& ceto__private__intermediate4 = this -> a;

                static_assert(requires { std::begin(ceto__private__intermediate4) + 2; }, "not a contiguous container");
                size_t ceto__private__size6 = std::size(ceto__private__intermediate4);
                for (size_t ceto__private__idx5 = 0; ; ceto__private__idx5++) {
                    if (std::size(ceto__private__intermediate4) != ceto__private__size6) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx5 >= ceto__private__size6) {
                        break;
                    }
                    const auto x = ceto__private__intermediate4[ceto__private__idx5];
                                    bar(x, x);
                
                                auto&& ceto__private__intermediate1 = this -> b;

                                static_assert(requires { std::begin(ceto__private__intermediate1) + 2; }, "not a contiguous container");
                                size_t ceto__private__size3 = std::size(ceto__private__intermediate1);
                                for (size_t ceto__private__idx2 = 0; ; ceto__private__idx2++) {
                                    if (std::size(ceto__private__intermediate1) != ceto__private__size3) {
                                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                        std::terminate();
                                    }
                                    if (ceto__private__idx2 >= ceto__private__size3) {
                                        break;
                                    }
                                    const auto y = ceto__private__intermediate1[ceto__private__idx2];
                                                        bar(x, y);

                                }
                                std::cout << ceto::bounds_check(this -> b, 0);

                }
            }

};

    inline auto create_foo() -> auto {
        auto f { ceto::make_shared_propagate_const<Foo>() } ;
        return f;
    }

    auto main() -> int {
        auto f { ceto::make_shared_propagate_const<Foo>() } ;
        (*ceto::mad(f)).foo();
        const auto c = create_foo();
        (*ceto::mad(c)).foo();
    }

