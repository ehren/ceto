
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
constexpr const int g { 5 } ; static_assert(std::is_convertible_v<decltype(5), decltype(g)>);
struct Foo : public ceto::shared_object, public std::enable_shared_from_this<Foo> {

    int a = []() {
            return (5 + g);
            }(); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype([]() {
            return (5 + g);
            }()), std::remove_cvref_t<decltype(a)>>);

    std::conditional_t<false,decltype([](const auto &x) {
            return (x + g);
            }),int> f;

    explicit Foo(std::conditional_t<false,decltype([](const auto &x) {
            return (x + g);
            }),int> f) : f(f) {}

    Foo() = delete;

};

constexpr const auto cg = "it's a global, no need to capture";
    auto main() -> int {
        const auto f = ceto::make_shared_propagate_const<const Foo>(2);
        const auto l = [f = ceto::default_capture(f)]() {
                return (g + (*ceto::mad(f)).a);
                };
        const auto l2 = []() {
                return cg;
                };
        ((((std::cout << (*ceto::mad(f)).f) << (*ceto::mad(f)).a) << l()) << "\n") << l2();
    }

