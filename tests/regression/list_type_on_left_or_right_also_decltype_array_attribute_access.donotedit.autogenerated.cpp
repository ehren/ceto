
#include "ceto.h"

;

;

;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
struct Foo : public ceto::shared_object, public std::enable_shared_from_this<Foo> {

    std::vector<int> a;

    std::vector<int> b = std::vector<int>{1, 2, 3}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<int>{1, 2, 3}), std::remove_cvref_t<decltype(b)>>);

    decltype(std::vector<int>{1, 2, 3}) c = std::vector<int>{1, 2, 3};

    decltype(std::vector {{1, 2, 3}}) d = std::vector {{1, 2, 3}};

    explicit Foo(std::vector<int> a) : a(std::move(a)) {}

    Foo() = delete;

};

    auto main() -> int {
        const std::vector<int> x = std::vector<int>{1, 2, 3}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<int>{1, 2, 3}), std::remove_cvref_t<decltype(x)>>);
        const auto l1 = std::vector {ceto::make_shared_propagate_const<const Foo>(x)};
        auto lm { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>())).a, 2))>>() } ;
        auto lm2 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>>>(), 0))>>())).a, 2))>>() } ;
        auto lm3 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>(), 0))>>())).a, 2))>>() } ;
        auto lm4 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>())).a, 2))>>() } ;
        auto lm5 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>())).a, 2))>>>(), 0))>>() } ;
        auto lm6 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<std::remove_cvref_t<decltype(ceto::bounds_check((*ceto::mad(std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>>>(), 0))>>())).a, 2))>>>(), 0))>>() } ;
        auto lm8 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>>(), 0))>>() } ;
        auto lm7 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>() } ;
        auto lm9 { std::vector<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::ranges::range_value_t<std::vector<std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Foo{std::declval<std::vector<int>>()})>>>>>>(), 0))>>() } ;
        const auto l2 = std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>>{ceto::make_shared_propagate_const<const Foo>(x)};
        const std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>> l3 = std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>>{ceto::make_shared_propagate_const<const Foo>(x)}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::shared_ptr<const Foo>>>{ceto::make_shared_propagate_const<const Foo>(x)}), std::remove_cvref_t<decltype(l3)>>);
        for(const auto& l : std::vector {{l1, l2, l3}}) {
            (lm).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(ceto::bounds_check(l, 0))).a, 2))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm)>>)); return ceto::bounds_check((*ceto::mad(ceto::bounds_check(l, 0))).a, 2); }());
            (lm2).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(ceto::bounds_check(l3, 0))).a, 2))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm2)>>)); return ceto::bounds_check((*ceto::mad(ceto::bounds_check(l3, 0))).a, 2); }());
            const auto a = ceto::bounds_check((*ceto::mad(ceto::bounds_check(l1, 0))).a, 2);
            (lm3).push_back(a);
            const auto b = ceto::bounds_check((*ceto::mad(ceto::bounds_check(l, 0))).a, 2);
            (lm4).push_back(b);
            (lm5).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(lm, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm5)>>)); return ceto::bounds_check(lm, 0); }());
            (lm6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(lm2, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm6)>>)); return ceto::bounds_check(lm2, 0); }());
            (lm7).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(l, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm7)>>)); return ceto::bounds_check(l, 0); }());
            (lm8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(lm7, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm8)>>)); return ceto::bounds_check(lm7, 0); }());
            const auto c = l;
            (lm9).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(c, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(lm9)>>)); return ceto::bounds_check(c, 0); }());
        }
        std::cout << ceto::bounds_check(lm, 0) << ceto::bounds_check(lm2, 0) << ceto::bounds_check(lm4, 0) << ceto::bounds_check((*ceto::mad(ceto::bounds_check(lm7, 0))).a, 0) << ceto::bounds_check((*ceto::mad(ceto::bounds_check(lm8, 0))).b, 1) << ceto::bounds_check((*ceto::mad(ceto::bounds_check(lm9, 0))).c, 2);
    }

