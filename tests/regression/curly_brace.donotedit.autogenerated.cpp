
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;

#include <array>
;
    auto main() -> int {
        const std::vector<std::vector<int>> l = {{1}, {1, 2, 3}};
        const std::vector<std::vector<int>> l2 = {{1, 2}};
        const std::vector<std::vector<int>> l3 = {{1}};
        const std::vector<std::vector<int>> l4 = {};
        const std::vector<int> a = {5, 2};
        const std::vector<std::vector<int>> a2 = {l};
        const std::vector<std::vector<int>> a3 = l; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(l), std::remove_cvref_t<decltype(a3)>>);
        const std::vector<std::vector<int>> a4 = {{l}};
        assert((((2 == (*ceto::mad(a)).size()) && (2 == (*ceto::mad(a2)).size())) && (2 == (*ceto::mad(a3)).size())) && (2 == (*ceto::mad(a4)).size()));
        
            auto&& ceto__private__intermediate5 = std::vector {{l, l2, l3, l4, a2}};

            static_assert(requires { std::begin(ceto__private__intermediate5) + 2; }, "not a contiguous container");
            size_t ceto__private__size7 = std::size(ceto__private__intermediate5);
            for (size_t ceto__private__idx6 = 0; ; ceto__private__idx6++) {
                if (std::size(ceto__private__intermediate5) != ceto__private__size7) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx6 >= ceto__private__size7) {
                    break;
                }
                const auto ll = ceto__private__intermediate5[ceto__private__idx6];
                    
    
                        static_assert(requires { std::begin(ll) + 2; }, "not a contiguous container");
                        size_t ceto__private__size4 = std::size(ll);
                        for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                            if (std::size(ll) != ceto__private__size4) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx3 >= ceto__private__size4) {
                                break;
                            }
                            const auto li = ll[ceto__private__idx3];
                        
    
                                        static_assert(requires { std::begin(li) + 2; }, "not a contiguous container");
                                        size_t ceto__private__size2 = std::size(li);
                                        for (size_t ceto__private__idx1 = 0; ; ceto__private__idx1++) {
                                            if (std::size(li) != ceto__private__size2) {
                                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                                std::terminate();
                                            }
                                            if (ceto__private__idx1 >= ceto__private__size2) {
                                                break;
                                            }
                                            const auto lk = li[ceto__private__idx1];
                                                                std::cout << lk;

                                        }
    
                        }
    
            }
            std::cout << ceto::bounds_check(ceto::bounds_check(l3, 0), 0);
        const std::array<int,4> arr = {{1, 2, 3, 4}};
        const std::array<int,2> arr2 = {1, 2};
        const std :: array<std :: array<int,3>,2> arr3 = {{{{1, 2, 3}}, {{4, 5, 6}}}};
        const std :: array<std :: array<int,3>,2> arr4 = {{{1, 2, 3}}};
        const std :: array<std :: array<int,3>,2> arr8 = {{{{1}}}};
        std::cout << ceto::bounds_check(arr, 3);
        std::cout << ceto::bounds_check(arr2, 1);
        
            auto&& ceto__private__intermediate8 = std::vector {{arr3, arr4}};

            static_assert(requires { std::begin(ceto__private__intermediate8) + 2; }, "not a contiguous container");
            size_t ceto__private__size10 = std::size(ceto__private__intermediate8);
            for (size_t ceto__private__idx9 = 0; ; ceto__private__idx9++) {
                if (std::size(ceto__private__intermediate8) != ceto__private__size10) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx9 >= ceto__private__size10) {
                    break;
                }
                const auto ll = ceto__private__intermediate8[ceto__private__idx9];
                            std::cout << ceto::bounds_check(ceto::bounds_check(ll, 0), 0);

            }
            const auto v = std::vector<int>(5, 42);
        std::cout << ceto::bounds_check(v, 4);
        assert((*ceto::mad(v)).size() == 5);
        const auto v2 = std::vector<int>{5, 42};
        assert((*ceto::mad(v2)).size() == 2);
        const std::vector<int> vv = std::vector<int>(5, 42); static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<int>(5, 42)), std::remove_cvref_t<decltype(vv)>>);
        std::cout << ceto::bounds_check(v, 4);
        assert((*ceto::mad(v)).size() == 5);
        const std::vector<int> vv2 = std::vector<int>{5, 42}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<int>{5, 42}), std::remove_cvref_t<decltype(vv2)>>);
        assert((*ceto::mad(v2)).size() == 2);
        const std::vector<int> v1 = {1, 2};
        const std::vector<std::vector<int>> vv1 = {v};
    }

