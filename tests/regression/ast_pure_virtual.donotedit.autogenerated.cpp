
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <map>
;
struct Node : public ceto::shared_object, public std::enable_shared_from_this<Node> {

    ceto::propagate_const<std::shared_ptr<const Node>> func;

    std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> args;

         virtual auto repr() const -> std::string = 0;

         virtual inline auto name() const -> std::optional<std::string> {
            return nullptr;
        }

    explicit Node(ceto::propagate_const<std::shared_ptr<const Node>> func, std::vector<ceto::propagate_const<std::shared_ptr<const Node>>> args) : func(std::move(func)), args(std::move(args)) {}

    Node() = delete;

};

struct Identifier : public Node {

    std::string _name;

        inline auto repr() const -> decltype((*ceto::mad(static_cast<ceto::propagate_const<std::shared_ptr<const Node>>>(nullptr))).repr()) {
            return (this -> _name);
        }

         virtual inline auto name() const -> decltype((*ceto::mad(std::declval<ceto::propagate_const<std::shared_ptr<const Node>>>())).name()) {
            return (this -> _name);
        }

    explicit Identifier(const std::string&  name) : Node (nullptr, std::vector<ceto::propagate_const<std::shared_ptr<const Node>>>{}), _name(name) {
    }

    Identifier() = delete;

};

    inline auto example_macro_body_workaround_no_fptr_syntax_yet(const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>  matches) -> ceto::propagate_const<std::shared_ptr<const Node>> {
        return nullptr;
    }

constexpr const auto glob = 0;
    inline auto macro_trampoline(const uintptr_t  fptr, const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>  matches) -> auto {
        const auto f = reinterpret_cast<decltype(+[](const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>  matches) -> ceto::propagate_const<std::shared_ptr<const Node>> {
                return nullptr;
                })>(fptr);
        const auto f2 = reinterpret_cast<decltype(+[](const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>  matches) -> ceto::propagate_const<std::shared_ptr<const Node>> {
                return nullptr;
                })>(0);
        const auto f3 = reinterpret_cast<decltype(+[](const std::map<std::string,ceto::propagate_const<std::shared_ptr<const Node>>>  matches) -> ceto::propagate_const<std::shared_ptr<const Node>> {
                return nullptr;
                })>(glob);
        const auto f4 = (&example_macro_body_workaround_no_fptr_syntax_yet);
        static_assert(std::is_same_v<decltype(f),decltype(f2)>);
        static_assert(std::is_same_v<decltype(f),decltype(f3)>);
        static_assert(std::is_same_v<decltype(f),decltype(f4)>);
        return (*f)(matches);
    }

    auto main() -> int {
        const auto id = ceto::make_shared_propagate_const<const Identifier>("a");
        std::cout << (*ceto::mad_smartptr((*ceto::mad(id)).name())).value();
    }

