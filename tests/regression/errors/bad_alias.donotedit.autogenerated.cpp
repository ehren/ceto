
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <functional>
;
template <typename ceto__private__C1>struct Foo : public ceto::enable_shared_from_this_base_for_templates {

    ceto__private__C1 vec;

        template <typename ceto__private__T12>
auto bad_method(const ceto__private__T12& x) -> void {
            (*ceto::mad(this -> vec)).clear();
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            std::cout << x;
            std::cout << "\ndone bad_method\n";
        }

    explicit Foo(ceto__private__C1 vec) : vec(std::move(vec)) {}

    Foo() = delete;

};

template <typename ceto__private__C3>struct FooStruct : public ceto::object {

    ceto__private__C3 foo;

    explicit FooStruct(ceto__private__C3 foo) : foo(std::move(foo)) {}

    FooStruct() = delete;

};

    template <typename ceto__private__T14>
auto bad(const ceto__private__T14& x,  auto  foo) -> void {
        (*ceto::mad((*ceto::mad(foo)).vec)).clear();
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad\n";
    }

    template <typename ceto__private__T15, typename ceto__private__T26>
auto bad2(const ceto__private__T15& x, const ceto__private__T26& foo) -> void {
        auto m { foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad2\n";
    }

    template <typename ceto__private__T17, typename ceto__private__T28>
auto bad3(const ceto__private__T17& x, const ceto__private__T28& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        std::cout << x;
        std::cout << "\ndone bad3\n";
    }

    template <typename ceto__private__T19, typename ceto__private__T210>
auto ok4(const ceto__private__T19& v, const ceto__private__T210& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << (*ceto::mad(v)).at(0);
        std::cout << "\ndone ok4\n";
    }

    template <typename ceto__private__T111>
auto bad5(const ceto__private__T111& x,  auto &  v) -> void {
static_assert(std::is_fundamental_v<decltype(x)>, "you cannot use the mut:ref param v (outside of an unsafe block) together with other non-fundamental (maybe reference/pointer holding) params");        (*ceto::mad(v)).clear();
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad5\n";
    }

    template <typename ceto__private__T112>
auto bad6(const ceto__private__T112& v,  auto &  v2) -> void {
static_assert(std::is_fundamental_v<decltype(v)>, "you cannot use the mut:ref param v2 (outside of an unsafe block) together with other non-fundamental (maybe reference/pointer holding) params");        
    
            static_assert(requires { std::begin(v) + 2; }, "not a contiguous container");
            size_t ceto__private__size14 = std::size(v);
            for (size_t ceto__private__idx13 = 0; ; ceto__private__idx13++) {
                if (std::size(v) != ceto__private__size14) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx13 >= ceto__private__size14) {
                    break;
                }
                 auto &  x = v[ceto__private__idx13];
                            bad5(/* unsafe: */ x, v2);
                    break;

            }
            std::cout << "\ndone bad6\n";
    }

    template <typename ceto__private__T115>
auto bad7(const ceto__private__T115& f,  auto &  v2) -> void {
static_assert(std::is_fundamental_v<decltype(f)>, "you cannot use the mut:ref param v2 (outside of an unsafe block) together with other non-fundamental (maybe reference/pointer holding) params");        
            auto&& ceto__private__intermediate16 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate16) + 2; }, "not a contiguous container");
            size_t ceto__private__size18 = std::size(ceto__private__intermediate16);
            for (size_t ceto__private__idx17 = 0; ; ceto__private__idx17++) {
                if (std::size(ceto__private__intermediate16) != ceto__private__size18) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx17 >= ceto__private__size18) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate16[ceto__private__idx17];
                            (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    if (1) {
                        // unsafe;
                        std::cout << x;
                    }
                    break;

            }
            std::cout << "\ndone bad7\n";
    }

    template <typename ceto__private__T119>
auto bad8(const ceto__private__T119& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate20 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate20) + 2; }, "not a contiguous container");
            size_t ceto__private__size22 = std::size(ceto__private__intermediate20);
            for (size_t ceto__private__idx21 = 0; ; ceto__private__idx21++) {
                if (std::size(ceto__private__intermediate20) != ceto__private__size22) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx21 >= ceto__private__size22) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate20[ceto__private__idx21];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    if (1) {
                        // unsafe;
                        std::cout << x;
                    }
                    break;

            }
            std::cout << "\ndone bad8\n";
    }

    template <typename ceto__private__T123>
auto ok9(const ceto__private__T123& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate24 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate24) + 2; }, "not a contiguous container");
            size_t ceto__private__size26 = std::size(ceto__private__intermediate24);
            for (size_t ceto__private__idx25 = 0; ; ceto__private__idx25++) {
                if (std::size(ceto__private__intermediate24) != ceto__private__size26) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx25 >= ceto__private__size26) {
                    break;
                }
                const auto x = ceto__private__intermediate24[ceto__private__idx25];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone ok9\n";
    }

    inline auto ok10( auto  f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate27 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate27) + 2; }, "not a contiguous container");
            size_t ceto__private__size29 = std::size(ceto__private__intermediate27);
            for (size_t ceto__private__idx28 = 0; ; ceto__private__idx28++) {
                if (std::size(ceto__private__intermediate27) != ceto__private__size29) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx28 >= ceto__private__size29) {
                    break;
                }
                const auto x = ceto__private__intermediate27[ceto__private__idx28];
                            ceto::append_or_push_back((*ceto::mad(f2)).vec, 1);
                    std::cout << x;
                    break;

            }
        }

    inline auto mutates( auto  f) -> void {
        (*ceto::mad((*ceto::mad(f)).vec)).push_back(42);
    }

struct HoldsFunc : public ceto::shared_object, public std::enable_shared_from_this<HoldsFunc> {

    std::function<void(const int &)> func;

    explicit HoldsFunc(std::function<void(const int &)> func) : func(func) {}

    HoldsFunc() = delete;

};

    auto main() -> int {
        auto vec { std::vector {{1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337}} } ;
        auto f { ceto::make_shared_propagate_const<decltype(Foo{vec})>(vec) } ;
        auto s { FooStruct{f} } ;
        bad([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); }(), f);
        bad2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).at(65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)); return (*ceto::mad((*ceto::mad(f)).vec)).at(65); }(), f);
        bad2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); }(), f);
        bad3([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(s)> && std::is_fundamental_v<std::remove_cvref_t<decltype(s)>>)) && true)); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); }(), s);
        std::cout << std::endl;
        ok4((*ceto::mad(f)).vec, s);
        bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype((*ceto::mad(f)).vec)> && std::is_fundamental_v<std::remove_cvref_t<decltype((*ceto::mad(f)).vec)>>)) && true)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }(), (*ceto::mad(f)).vec);
        bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](0))>  || (!std::is_reference_v<decltype((*ceto::mad(f)).vec)> && std::is_fundamental_v<std::remove_cvref_t<decltype((*ceto::mad(f)).vec)>>)) && true)); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](0); }(), (*ceto::mad(f)).vec);
        bad6((*ceto::mad(f)).vec, (*ceto::mad(f)).vec);
        (*ceto::mad(f)).bad_method([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](0))> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(f)>>)); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](0); }());
        bad7(f, (*ceto::mad(f)).vec);
        bad8(f, f);
        ok9(f, f);
        ok10(f, f);
        const auto bad_lambda = [f = ceto::default_capture(f)](const auto &x) {
                auto f_m { f } ;
                (*ceto::mad((*ceto::mad(f_m)).vec)).push_back(42);
                std::cout << x;
                return;
                };
        bad_lambda([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }());
        const auto bad_lambda2 = [f = ceto::default_capture(f)](const auto &x) {
                mutates(f);
                std::cout << x;
                return;
                };
        bad_lambda2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda2)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }());
        const auto bad_lambda3 = [](const auto &x, const auto &f) {
                mutates(f);
                std::cout << x;
                return;
                };
        bad_lambda3([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda3)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }(), f);
        const auto has_bad_lambda_member1 = ceto::make_shared_propagate_const<const HoldsFunc>([f = ceto::default_capture(f)](const auto &x) {
                mutates(f);
                std::cout << x;
                return;
                });
        const auto ok_lambda5 = []( auto  x,  auto  f) {
                mutates(f);
                std::cout << x;
                return;
                };
        const auto val = ceto::bounds_check((*ceto::mad(f)).vec, 0);
        (*ceto::mad(has_bad_lambda_member1)).func(val);
        (*ceto::mad(has_bad_lambda_member1)).func([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(has_bad_lambda_member1)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }());
        ok_lambda5(val, f);
        ok_lambda5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && ceto::IsStateless<std::remove_cvref_t<decltype(ok_lambda5)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }(), f);
        const auto bad_func_member_copy = (*ceto::mad(has_bad_lambda_member1)).func;
        bad_func_member_copy([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_func_member_copy)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }());
        const auto bad_lambda_like_bad5 = [](const auto &x,  auto &  v) {
                (*ceto::mad(v)).clear();
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                (*ceto::mad(v)).push_back(1);
                std::cout << x;
                std::cout << "\ndone bad_lambda_like_bad5\n";
                return;
                };
        bad_lambda_like_bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype((*ceto::mad(f)).vec)> && std::is_fundamental_v<std::remove_cvref_t<decltype((*ceto::mad(f)).vec)>>)) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda_like_bad5)>>)); return ceto::bounds_check((*ceto::mad(f)).vec, 0); }(), (*ceto::mad(f)).vec);
        const auto bad_lambda_like_bad8 = [](const auto &f,  auto  f2) {
                
                    auto&& ceto__private__intermediate30 = (*ceto::mad(f)).vec;

                    static_assert(requires { std::begin(ceto__private__intermediate30) + 2; }, "not a contiguous container");
                    size_t ceto__private__size32 = std::size(ceto__private__intermediate30);
                    for (size_t ceto__private__idx31 = 0; ; ceto__private__idx31++) {
                        if (std::size(ceto__private__intermediate30) != ceto__private__size32) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx31 >= ceto__private__size32) {
                            break;
                        }
                         const auto &  x = ceto__private__intermediate30[ceto__private__idx31];
                                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                                    std::cout << /* unsafe: */ x;
                                    break;

                    }
                    std::cout << "\ndone bad_lambda_like_bad8\n";
                return;
                };
        bad_lambda_like_bad8(f, f);
    }

