
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
template <typename ceto__private__C1>struct Foo : public ceto::enable_shared_from_this_base_for_templates {

    ceto__private__C1 vec;

        template <typename T1>
auto bad_method(const T1& x) -> void {
            (*ceto::mad(this -> vec)).clear();
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            std::cout << x;
            std::cout << "\ndone bad_method\n";
        }

    explicit Foo(ceto__private__C1 vec) : vec(std::move(vec)) {}

    Foo() = delete;

};

template <typename ceto__private__C2>struct FooStruct : public ceto::object {

    ceto__private__C2 foo;

    explicit FooStruct(ceto__private__C2 foo) : foo(std::move(foo)) {}

    FooStruct() = delete;

};

    template <typename T1>
auto bad(const T1& x,  auto  foo) -> void {
        (*ceto::mad((*ceto::mad(foo)).vec)).clear();
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad\n";
    }

    template <typename T1, typename T2>
auto bad2(const T1& x, const T2& foo) -> void {
        auto m { foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad2\n";
    }

    template <typename T1, typename T2>
auto bad3(const T1& x, const T2& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        std::cout << x;
        std::cout << "\ndone bad3\n";
    }

    template <typename T1, typename T2>
auto ok4(const T1& v, const T2& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << (*ceto::mad(v)).at(0);
        std::cout << "\ndone ok4\n";
    }

    template <typename T1>
auto bad5(const T1& x,  auto &  v) -> void {
        (*ceto::mad(v)).clear();
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad5\n";
    }

    template <typename T1>
auto bad6(const T1& v,  auto &  v2) -> void {
        
    
            static_assert(requires { std::begin(v) + 2; }, "not a contiguous container");
            size_t ceto__private__size4 = std::size(v);
            for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                if (std::size(v) != ceto__private__size4) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx3 >= ceto__private__size4) {
                    break;
                }
                 auto &  x = v[ceto__private__idx3];
                            bad5([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype(x)>  ); return x; } (), v2);
                    break;

            }
            std::cout << "\ndone bad6\n";
    }

    template <typename T1>
auto bad7(const T1& f,  auto &  v2) -> void {
        
            auto&& ceto__private__intermediate5 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate5) + 2; }, "not a contiguous container");
            size_t ceto__private__size7 = std::size(ceto__private__intermediate5);
            for (size_t ceto__private__idx6 = 0; ; ceto__private__idx6++) {
                if (std::size(ceto__private__intermediate5) != ceto__private__size7) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx6 >= ceto__private__size7) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate5[ceto__private__idx6];
                            (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone bad7\n";
    }

    template <typename T1>
auto bad8(const T1& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate8 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate8) + 2; }, "not a contiguous container");
            size_t ceto__private__size10 = std::size(ceto__private__intermediate8);
            for (size_t ceto__private__idx9 = 0; ; ceto__private__idx9++) {
                if (std::size(ceto__private__intermediate8) != ceto__private__size10) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx9 >= ceto__private__size10) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate8[ceto__private__idx9];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone bad8\n";
    }

    template <typename T1>
auto ok9(const T1& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate11 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate11) + 2; }, "not a contiguous container");
            size_t ceto__private__size13 = std::size(ceto__private__intermediate11);
            for (size_t ceto__private__idx12 = 0; ; ceto__private__idx12++) {
                if (std::size(ceto__private__intermediate11) != ceto__private__size13) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx12 >= ceto__private__size13) {
                    break;
                }
                const auto x = ceto__private__intermediate11[ceto__private__idx12];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone ok9\n";
    }

    auto main() -> int {
        auto vec { std::vector {{1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337}} } ;
        auto f { ceto::make_shared_propagate_const<decltype(Foo{vec})>(vec) } ;
        auto s { FooStruct{f} } ;
        bad([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), f);
        bad2([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).at(65))>  ); return (*ceto::mad((*ceto::mad(f)).vec)).at(65); } (), f);
        bad2([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), f);
        bad3([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), s);
        std::cout << std::endl;
        ok4((*ceto::mad(f)).vec, s);
        bad5([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 65))>  ); return ceto::bounds_check((*ceto::mad(f)).vec, 65); } (), (*ceto::mad(f)).vec);
        bad5([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), (*ceto::mad(f)).vec);
        bad6((*ceto::mad(f)).vec, (*ceto::mad(f)).vec);
        (*ceto::mad(f)).bad_method([&]() -> decltype(auto) { static_assert(!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || ceto::IsContainer<std::remove_cvref_t<decltype(f)>> ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } ());
        bad7(f, (*ceto::mad(f)).vec);
        bad8(f, f);
        ok9(f, f);
    }

