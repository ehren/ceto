
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <functional>
;
template <typename ceto__private__C1>struct Foo : public ceto::enable_shared_from_this_base_for_templates {

    ceto__private__C1 vec;

        template <typename T1>
auto bad_method(const T1& x) -> void {
            (*ceto::mad(this -> vec)).clear();
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            (*ceto::mad(this -> vec)).push_back(42);
            std::cout << x;
            std::cout << "\ndone bad_method\n";
        }

    explicit Foo(ceto__private__C1 vec) : vec(std::move(vec)) {}

    Foo() = delete;

};

template <typename ceto__private__C2>struct FooStruct : public ceto::object {

    ceto__private__C2 foo;

    explicit FooStruct(ceto__private__C2 foo) : foo(std::move(foo)) {}

    FooStruct() = delete;

};

    template <typename T1>
auto bad(const T1& x,  auto  foo) -> void {
        (*ceto::mad((*ceto::mad(foo)).vec)).clear();
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(foo)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad\n";
    }

    template <typename T1, typename T2>
auto bad2(const T1& x, const T2& foo) -> void {
        auto m { foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad2\n";
    }

    template <typename T1, typename T2>
auto bad3(const T1& x, const T2& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(3);
        std::cout << x;
        std::cout << "\ndone bad3\n";
    }

    template <typename T1, typename T2>
auto ok4(const T1& v, const T2& foo_struct) -> void {
        auto fm { foo_struct } ;
        auto m { (*ceto::mad(fm)).foo } ;
        (*ceto::mad((*ceto::mad(m)).vec)).clear();
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        (*ceto::mad((*ceto::mad(m)).vec)).push_back(1);
        std::cout << (*ceto::mad(v)).at(0);
        std::cout << "\ndone ok4\n";
    }

    template <typename T1>
auto bad5(const T1& x,  auto &  v) -> void {
        (*ceto::mad(v)).clear();
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        (*ceto::mad(v)).push_back(1);
        std::cout << x;
        std::cout << "\ndone bad5\n";
    }

    template <typename T1>
auto bad6(const T1& v,  auto &  v2) -> void {
        
    
            static_assert(requires { std::begin(v) + 2; }, "not a contiguous container");
            size_t ceto__private__size4 = std::size(v);
            for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                if (std::size(v) != ceto__private__size4) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx3 >= ceto__private__size4) {
                    break;
                }
                 auto &  x = v[ceto__private__idx3];
                            bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)>  || (!std::is_reference_v<decltype(v2)> && std::is_fundamental_v<std::remove_cvref_t<decltype(v2)>>)) && true)  ); return x; } (), v2);
                    break;

            }
            std::cout << "\ndone bad6\n";
    }

    template <typename T1>
auto bad7(const T1& f,  auto &  v2) -> void {
        
            auto&& ceto__private__intermediate5 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate5) + 2; }, "not a contiguous container");
            size_t ceto__private__size7 = std::size(ceto__private__intermediate5);
            for (size_t ceto__private__idx6 = 0; ; ceto__private__idx6++) {
                if (std::size(ceto__private__intermediate5) != ceto__private__size7) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx6 >= ceto__private__size7) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate5[ceto__private__idx6];
                            (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    (*ceto::mad(v2)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone bad7\n";
    }

    template <typename T1>
auto bad8(const T1& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate8 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate8) + 2; }, "not a contiguous container");
            size_t ceto__private__size10 = std::size(ceto__private__intermediate8);
            for (size_t ceto__private__idx9 = 0; ; ceto__private__idx9++) {
                if (std::size(ceto__private__intermediate8) != ceto__private__size10) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx9 >= ceto__private__size10) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate8[ceto__private__idx9];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone bad8\n";
    }

    template <typename T1>
auto ok9(const T1& f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate11 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate11) + 2; }, "not a contiguous container");
            size_t ceto__private__size13 = std::size(ceto__private__intermediate11);
            for (size_t ceto__private__idx12 = 0; ; ceto__private__idx12++) {
                if (std::size(ceto__private__intermediate11) != ceto__private__size13) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx12 >= ceto__private__size13) {
                    break;
                }
                const auto x = ceto__private__intermediate11[ceto__private__idx12];
                            (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    (*ceto::mad((*ceto::mad(f2)).vec)).push_back(1);
                    std::cout << x;
                    break;

            }
            std::cout << "\ndone ok9\n";
    }

    inline auto ok10( auto  f,  auto  f2) -> void {
        
            auto&& ceto__private__intermediate14 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate14) + 2; }, "not a contiguous container");
            size_t ceto__private__size16 = std::size(ceto__private__intermediate14);
            for (size_t ceto__private__idx15 = 0; ; ceto__private__idx15++) {
                if (std::size(ceto__private__intermediate14) != ceto__private__size16) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx15 >= ceto__private__size16) {
                    break;
                }
                const auto x = ceto__private__intermediate14[ceto__private__idx15];
                            ceto::append_or_push_back((*ceto::mad(f2)).vec, 1);
                    std::cout << x;
                    break;

            }
        }

    inline auto mutates( auto  f) -> void {
        (*ceto::mad((*ceto::mad(f)).vec)).push_back(42);
    }

struct HoldsFunc : public ceto::shared_object, public std::enable_shared_from_this<HoldsFunc> {

    std::function<void(const int &)> func;

    explicit HoldsFunc(std::function<void(const int &)> func) : func(func) {}

    HoldsFunc() = delete;

};

    auto main() -> int {
        auto vec { std::vector {{1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337, 1337}} } ;
        auto f { ceto::make_shared_propagate_const<decltype(Foo{vec})>(vec) } ;
        auto s { FooStruct{f} } ;
        bad([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), f);
        bad2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).at(65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)  ); return (*ceto::mad((*ceto::mad(f)).vec)).at(65); } (), f);
        bad2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && true)  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), f);
        bad3([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](65))>  || (!std::is_reference_v<decltype(s)> && std::is_fundamental_v<std::remove_cvref_t<decltype(s)>>)) && true)  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](65); } (), s);
        std::cout << std::endl;
        ok4((*ceto::mad(f)).vec, s);
        bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype((*ceto::mad(f)).vec)> && std::is_fundamental_v<std::remove_cvref_t<decltype((*ceto::mad(f)).vec)>>)) && true)  ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } (), (*ceto::mad(f)).vec);
        bad5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](0))>  || (!std::is_reference_v<decltype((*ceto::mad(f)).vec)> && std::is_fundamental_v<std::remove_cvref_t<decltype((*ceto::mad(f)).vec)>>)) && true)  ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](0); } (), (*ceto::mad(f)).vec);
        bad6((*ceto::mad(f)).vec, (*ceto::mad(f)).vec);
        (*ceto::mad(f)).bad_method([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad((*ceto::mad(f)).vec)).operator[](0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(f)>> ); return (*ceto::mad((*ceto::mad(f)).vec)).operator[](0); } ());
        bad7(f, (*ceto::mad(f)).vec);
        bad8(f, f);
        ok9(f, f);
        ok10(f, f);
        const auto bad_lambda = [f = ceto::default_capture(f)](const auto &x) {
                auto f_m { f } ;
                (*ceto::mad((*ceto::mad(f_m)).vec)).push_back(42);
                std::cout << x;
                return;
                };
        bad_lambda([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda)>>)  ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } ());
        const auto bad_lambda2 = [f = ceto::default_capture(f)](const auto &x) {
                mutates(f);
                std::cout << x;
                return;
                };
        bad_lambda2([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda2)>>)  ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } ());
        const auto bad_lambda3 = [](const auto &x, const auto &f) {
                mutates(f);
                std::cout << x;
                return;
                };
        bad_lambda3([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && ceto::IsStateless<std::remove_cvref_t<decltype(bad_lambda3)>>)  ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } (), f);
        const auto has_bad_lambda_member1 = ceto::make_shared_propagate_const<const HoldsFunc>([f = ceto::default_capture(f)](const auto &x) {
                mutates(f);
                std::cout << x;
                return;
                });
        const auto ok_lambda5 = []( auto  x,  auto  f) {
                mutates(f);
                std::cout << x;
                return;
                };
        const auto val = ceto::bounds_check((*ceto::mad(f)).vec, 0);
        (*ceto::mad(has_bad_lambda_member1)).func(val);
        (*ceto::mad(has_bad_lambda_member1)).func([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(has_bad_lambda_member1)>> ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } ());
        ok_lambda5(val, f);
        ok_lambda5([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(ceto::bounds_check((*ceto::mad(f)).vec, 0))>  || (!std::is_reference_v<decltype(f)> && std::is_fundamental_v<std::remove_cvref_t<decltype(f)>>)) && ceto::IsStateless<std::remove_cvref_t<decltype(ok_lambda5)>>)  ); return ceto::bounds_check((*ceto::mad(f)).vec, 0); } (), f);
    }

