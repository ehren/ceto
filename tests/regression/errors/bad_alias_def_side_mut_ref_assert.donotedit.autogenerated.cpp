
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
template <typename ceto__private__C1>struct Foo : public ceto::enable_shared_from_this_base_for_templates {

    ceto__private__C1 vec;

    explicit Foo(ceto__private__C1 vec) : vec(std::move(vec)) {}

    Foo() = delete;

};

template <typename ceto__private__C2>struct FooStruct : public ceto::object {

    ceto__private__C2 foo;

    explicit FooStruct(ceto__private__C2 foo) : foo(std::move(foo)) {}

    FooStruct() = delete;

};

    template <typename ceto__private__T13>
auto bad7(const ceto__private__T13& f,  auto &  v2) -> void {
static_assert(std::is_fundamental_v<decltype(f)>, "you cannot use the mut:ref param v2 (outside of an unsafe block) together with other non-fundamental (maybe reference/pointer holding) params");        
            auto&& ceto__private__intermediate4 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate4) + 2; }, "not a contiguous container");
            size_t ceto__private__size6 = std::size(ceto__private__intermediate4);
            for (size_t ceto__private__idx5 = 0; ; ceto__private__idx5++) {
                if (std::size(ceto__private__intermediate4) != ceto__private__size6) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx5 >= ceto__private__size6) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate4[ceto__private__idx5];
                            (*ceto::mad(v2)).push_back(1);
                    if (1) {
                        // unsafe;
                        std::cout << x;
                    }
                    break;

            }
            std::cout << "\ndone bad7\n";
    }

    inline auto bad7_explicit( const auto &  f,  auto &  v2) -> void {
static_assert(std::is_fundamental_v<decltype(f)>, "you cannot use the mut:ref param v2 (outside of an unsafe block) together with other non-fundamental (maybe reference/pointer holding) params");        
            auto&& ceto__private__intermediate7 = (*ceto::mad(f)).vec;

            static_assert(requires { std::begin(ceto__private__intermediate7) + 2; }, "not a contiguous container");
            size_t ceto__private__size9 = std::size(ceto__private__intermediate7);
            for (size_t ceto__private__idx8 = 0; ; ceto__private__idx8++) {
                if (std::size(ceto__private__intermediate7) != ceto__private__size9) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx8 >= ceto__private__size9) {
                    break;
                }
                 const auto &  x = ceto__private__intermediate7[ceto__private__idx8];
                            (*ceto::mad(v2)).push_back(1);
                    if (1) {
                        // unsafe;
                        std::cout << x;
                    }
                    break;

            }
            std::cout << "\ndone bad7_explicit\n";
    }

    auto main() -> int {
        auto vec { std::vector {{1, 2, 3, 4}} } ;
        auto f { ceto::make_shared_propagate_const<decltype(Foo{vec})>(vec) } ;
        auto s { FooStruct{f} } ;
        bad7(f, (*ceto::mad(f)).vec);
        bad7_explicit(f, (*ceto::mad(f)).vec);
    }

