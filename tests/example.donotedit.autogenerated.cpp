
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <numeric>
;
#include <ranges>
;
#include <iostream>
;
#include <future>
;
template <typename ceto__private__C14>struct Foo : public ceto::enable_shared_from_this_base_for_templates {

    ceto__private__C14 data_member;

        template <typename ceto__private__T115>
auto method(const ceto__private__T115& param) const -> auto {
            const auto self = ceto::shared_from(this);
            std::cout << (*ceto::mad(param)).size() << "\n";
            return self;
        }

        inline auto size() const -> auto {
            return (*ceto::mad(this -> data_member)).size();
        }

    explicit Foo(ceto__private__C14 data_member) : data_member(std::move(data_member)) {}

    Foo() = delete;

};

    template <typename ceto__private__T116>
auto calls_method(const ceto__private__T116& f) -> auto {
        return (*ceto::mad(f)).method(f);
    }

struct UniqueFoo : public ceto::object {

    std::vector<ceto::propagate_const<std::unique_ptr<const UniqueFoo>>> consumed = std::vector<ceto::propagate_const<std::unique_ptr<const UniqueFoo>>>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<ceto::propagate_const<std::unique_ptr<const UniqueFoo>>>{}), std::remove_cvref_t<decltype(consumed)>>);

        inline auto size() const -> auto {
            return (*ceto::mad(this -> consumed)).size();
        }

        inline auto consuming_method( ceto::propagate_const<std::unique_ptr<const UniqueFoo>>  u) -> void {
            (*ceto::mad(ceto::make_shared_propagate_const<const decltype(Foo{42})>(42))).method(u);
            (*ceto::mad(this -> consumed)).push_back(std::move(u));
        }

};

    inline auto string_join(const std::vector<std::string>&  vec, const decltype(std::string {", "})&  sep = std::string {", "}) -> std::string {
        static_assert(std::is_same_v<decltype(vec),const std::vector<std::string> &>);
        static_assert(std::is_same_v<decltype(sep),const std::string &>);
        if ((*ceto::mad(vec)).empty()) {
            return "";
        }
         // external C++: std.accumulate
;
        if (1) {
            // unsafe;
            return std::accumulate((*ceto::mad(vec)).cbegin() + 1, (*ceto::mad(vec)).cend(), ceto::bounds_check(vec, 0), [&sep](const auto &a, const auto &b) {
                    return (a + sep + b);
                    });
        }
    }


;
    auto main(const int  argc, const char * *  argv) -> int {
        const auto args = [&]() {
                auto ceto__private__ident__1 { std::vector<std::remove_cvref_t<decltype(std::string(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::vector(argv, argv+std::declval<int>()))>>>()))>>() } ;
                auto && ceto__private__ident__2 { std::vector(/* unsafe: */ argv, /* unsafe: */ argv + argc) } ;
                ceto::util::maybe_reserve(ceto__private__ident__1, /* unsafe: */ ceto__private__ident__2);
                ceto::safe_for_loop<!std::is_reference_v<decltype((/* unsafe: */ ceto__private__ident__2))> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__2)>>>(/* unsafe: */ ceto__private__ident__2, [&](const auto a) -> ceto::LoopControl {
                    (ceto__private__ident__1).push_back(std::string([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(a)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__1)>>)); return a; }()));
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__1;
                }();
        const auto summary = string_join(args, ", ");
        const auto f = ceto::make_shared_propagate_const<const decltype(Foo{summary})>(summary);
        (*ceto::mad(f)).method(args);
        (*ceto::mad(f)).method(f);
        calls_method(f);
         // external C++: std.async, std.launch.async
;
        auto fut { std::async(std::launch::async, [f = ceto::default_capture(f)]() {
                return (*ceto::mad(f)).method(f);
                }) } ;
        (*ceto::mad((*ceto::mad(fut)).get())).method(f);
        auto u = ceto::make_unique_propagate_const<UniqueFoo>();
        auto u2 = ceto::make_unique_propagate_const<const UniqueFoo>();
        (*ceto::mad(u)).consuming_method(std::move(u2));
        (*ceto::mad(u)).consuming_method(std::move(u));
    }

