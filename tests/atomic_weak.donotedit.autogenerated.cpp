
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <atomic>
;
#include <ranges>
;
struct Task : public ceto::shared_object, public std::enable_shared_from_this<Task> {

    int _id;

        inline auto id() const -> auto {
            return (this -> _id);
        }

        inline auto action() const -> void {
            ((std::cout << "action: ") << (this -> _id)) << "\n";
            std::this_thread::sleep_for(std::chrono::milliseconds((this -> _id) * 100));
            ((std::cout << "finished: ") << (this -> _id)) << "\n";
        }

        ~Task() {
            ((std::cout << "Task ") << (this -> _id)) << " dead\n";
        }

    explicit Task(int _id) : _id(_id) {}

    Task() = delete;

};

struct Executor : public ceto::shared_object, public std::enable_shared_from_this<Executor> {

    std::atomic<std::weak_ptr<const Task>> last_submitted = {};

    std::atomic<std::weak_ptr<const Task>> last_finished = {};

        inline auto do_something(const ceto::propagate_const<std::shared_ptr<const Task>>&  task) -> void {
            (this -> last_submitted) = task;
            (*ceto::mad(task)).action();
            (this -> last_finished) = task;
        }

        ~Executor() {
            ((((std::cout << "Last task submitted: ") << [&]() {if (const auto strong = (*ceto::mad((*ceto::mad(this -> last_submitted)).load())).lock()) {
                return std::to_string([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad(strong)).id())> ) && true)); return (*ceto::mad(strong)).id(); }());
            } else {
                return std::string {"Last submitted task not found"};
            }}()
) << "\nLast task finished: ") << [&]() {if (const auto strong = (*ceto::mad((*ceto::mad(this -> last_finished)).load())).lock()) {
                return std::to_string([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype((*ceto::mad(strong)).id())> ) && true)); return (*ceto::mad(strong)).id(); }());
            } else {
                return std::string {"Last finished task not found"};
            }}()
) << "\n";
        }

};

    inline auto launch(const std::vector<ceto::propagate_const<std::shared_ptr<const Task>>>&  tasks) -> void {
        auto executor { ceto::make_shared_propagate_const<Executor>() } ;
        std::vector<std::thread> threads = std::vector<std::thread>{}; static_assert(ceto::is_non_aggregate_init_and_if_convertible_then_non_narrowing_v<decltype(std::vector<std::thread>{}), std::remove_cvref_t<decltype(threads)>>);
        
    
            static_assert(requires { std::begin(tasks) + 2; }, "not a contiguous container");
            size_t ceto__private__size2 = std::size(tasks);
            for (size_t ceto__private__idx1 = 0; ; ceto__private__idx1++) {
                if (std::size(tasks) != ceto__private__size2) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx1 >= ceto__private__size2) {
                    break;
                }
                const auto task = tasks[ceto__private__idx1];
                            (threads).push_back(std::thread([task = ceto::default_capture(task), executor = ceto::default_capture(executor)]() {
                            return (*ceto::mad(executor)).do_something([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(task)> ) && true)); return task; }());
                            }));

            }
            
    
            static_assert(requires { std::begin(threads) + 2; }, "not a contiguous container");
            size_t ceto__private__size4 = std::size(threads);
            for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                if (std::size(threads) != ceto__private__size4) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx3 >= ceto__private__size4) {
                    break;
                }
                 auto &&  thread = threads[ceto__private__idx3];
                            (*ceto::mad(thread)).join();

            }
        }

    auto main() -> int {
        auto tasks { std::vector<ceto::propagate_const<std::shared_ptr<const decltype(Task{std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>()})>>>() } ;
        
            auto&& ceto__private__intermediate5 = std::ranges::iota_view(0, 10);

            static_assert(requires { std::begin(ceto__private__intermediate5) + 2; }, "not a contiguous container");
            size_t ceto__private__size7 = std::size(ceto__private__intermediate5);
            for (size_t ceto__private__idx6 = 0; ; ceto__private__idx6++) {
                if (std::size(ceto__private__intermediate5) != ceto__private__size7) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx6 >= ceto__private__size7) {
                    break;
                }
                const auto i = ceto__private__intermediate5[ceto__private__idx6];
                            (tasks).push_back(ceto::make_shared_propagate_const<const Task>([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(i)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(tasks)>>)); return i; }()));

            }
            launch(tasks);
    }

