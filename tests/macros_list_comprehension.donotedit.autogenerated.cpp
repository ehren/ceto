
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <ranges>
;

;

;

;
#include "macros_list_comprehension.donotedit.autogenerated.h"
;
    auto main() -> int {
        const auto l = [&]() {
                auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param1) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param1;
                    if ((x % 2) == 0) {
                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                    }
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__8;
                }();
        ceto::safe_for_loop<!std::is_reference_v<decltype(l)> && ceto::OwningContainer<std::remove_cvref_t<decltype(l)>>>(l, [&](auto &&ceto__private__lambda_param2) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param2;
            std::cout << x;
    return ceto::LoopControl::Continue;
});        const auto l2 = [&]() {
                auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                        auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                        maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param3) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param3;
                            if ((x % 2) == 0) {
                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                            }
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__8;
                        }())>>>()+1)>() } ;
                auto && ceto__private__ident__7 { l } ;
                maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param4) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param4;
                    (ceto__private__ident__6).push_back(x + 1);
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__6;
                }();
        ceto::safe_for_loop<!std::is_reference_v<decltype([&]() {
                auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                                auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                                maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param5) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param5;
                                    if ((x % 2) == 0) {
                                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                    }
    return ceto::LoopControl::Continue;
});                                return ceto__private__ident__8;
                                }())>>>()+1)>() } ;
                        auto && ceto__private__ident__7 { l } ;
                        maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param6) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param6;
                            (ceto__private__ident__6).push_back(x + 1);
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__6;
                        }())>>>() } ;
                auto && ceto__private__ident__11 { l2 } ;
                maybe_reserve(ceto__private__ident__10, /* unsafe: */ ceto__private__ident__11);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__11)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__11)>>>(/* unsafe: */ ceto__private__ident__11, [&](auto &&ceto__private__lambda_param7) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param7;
                    if (x > 5) {
                        (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                    }
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__10;
                }())> && ceto::OwningContainer<std::remove_cvref_t<decltype([&]() {
                auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                                auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                                maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param5) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param5;
                                    if ((x % 2) == 0) {
                                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                    }
    return ceto::LoopControl::Continue;
});                                return ceto__private__ident__8;
                                }())>>>()+1)>() } ;
                        auto && ceto__private__ident__7 { l } ;
                        maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param6) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param6;
                            (ceto__private__ident__6).push_back(x + 1);
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__6;
                        }())>>>() } ;
                auto && ceto__private__ident__11 { l2 } ;
                maybe_reserve(ceto__private__ident__10, /* unsafe: */ ceto__private__ident__11);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__11)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__11)>>>(/* unsafe: */ ceto__private__ident__11, [&](auto &&ceto__private__lambda_param7) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param7;
                    if (x > 5) {
                        (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                    }
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__10;
                }())>>>([&]() {
                auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                                auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                                maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param5) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param5;
                                    if ((x % 2) == 0) {
                                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                    }
    return ceto::LoopControl::Continue;
});                                return ceto__private__ident__8;
                                }())>>>()+1)>() } ;
                        auto && ceto__private__ident__7 { l } ;
                        maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param6) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param6;
                            (ceto__private__ident__6).push_back(x + 1);
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__6;
                        }())>>>() } ;
                auto && ceto__private__ident__11 { l2 } ;
                maybe_reserve(ceto__private__ident__10, /* unsafe: */ ceto__private__ident__11);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__11)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__11)>>>(/* unsafe: */ ceto__private__ident__11, [&](auto &&ceto__private__lambda_param7) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param7;
                    if (x > 5) {
                        (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                    }
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__10;
                }(), [&](auto &&ceto__private__lambda_param8) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param8;
            std::cout << i;
    return ceto::LoopControl::Continue;
});        ceto::safe_for_loop<!std::is_reference_v<decltype([&]() {
                auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                        auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                        maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param9) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param9;
                            if ((x % 2) == 0) {
                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                            }
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__8;
                        }())>>>()*100)>() } ;
                auto && ceto__private__ident__7 { l } ;
                maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param10) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param10;
                    (ceto__private__ident__6).push_back(x * 100);
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__6;
                }())> && ceto::OwningContainer<std::remove_cvref_t<decltype([&]() {
                auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                        auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                        maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param9) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param9;
                            if ((x % 2) == 0) {
                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                            }
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__8;
                        }())>>>()*100)>() } ;
                auto && ceto__private__ident__7 { l } ;
                maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param10) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param10;
                    (ceto__private__ident__6).push_back(x * 100);
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__6;
                }())>>>([&]() {
                auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                        auto && ceto__private__ident__9 { std::ranges::iota_view(0, 10) } ;
                        maybe_reserve(ceto__private__ident__8, /* unsafe: */ ceto__private__ident__9);
                        ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__9)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__9)>>>(/* unsafe: */ ceto__private__ident__9, [&](auto &&ceto__private__lambda_param9) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param9;
                            if ((x % 2) == 0) {
                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                            }
    return ceto::LoopControl::Continue;
});                        return ceto__private__ident__8;
                        }())>>>()*100)>() } ;
                auto && ceto__private__ident__7 { l } ;
                maybe_reserve(ceto__private__ident__6, /* unsafe: */ ceto__private__ident__7);
                ceto::safe_for_loop<!std::is_reference_v<decltype(/* unsafe: */ ceto__private__ident__7)> && ceto::OwningContainer<std::remove_cvref_t<decltype(/* unsafe: */ ceto__private__ident__7)>>>(/* unsafe: */ ceto__private__ident__7, [&](auto &&ceto__private__lambda_param10) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param10;
                    (ceto__private__ident__6).push_back(x * 100);
    return ceto::LoopControl::Continue;
});                return ceto__private__ident__6;
                }(), [&](auto &&ceto__private__lambda_param11) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param11;
            std::cout << i;
    return ceto::LoopControl::Continue;
});    }

