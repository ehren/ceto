
#include "ceto.h"

;

;

;

;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <ranges>
;

;

;
     template<typename T> inline auto maybe_reserve( std::vector<T> &  vec,  auto &&  sized) -> void requires (requires () {    std::size(sized);
}) {
         // unsafe external C++: std.forward
;
        (*ceto::mad(vec)).reserve(std::size(std::forward<decltype(sized)>(sized)));
    }

     template<typename T> inline auto maybe_reserve( std::vector<T> &  vec,  auto &&  unsized) -> void requires (!requires () {    std::size(unsized);
}) {
        ; // pass
    }


;
#include "macros_list_comprehension.donotedit.autogenerated.h"
;
    auto main() -> int {
        const auto l = []( auto &&  ceto__private__ident__9) {
                auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__9)>>() } ;
                maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
                
    
                    static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
                    size_t ceto__private__size2 = std::size(ceto__private__ident__9);
                    for (size_t ceto__private__idx1 = 0; ; ceto__private__idx1++) {
                        if (std::size(ceto__private__ident__9) != ceto__private__size2) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx1 >= ceto__private__size2) {
                            break ;
                        }
                        const auto x = ceto__private__ident__9[ceto__private__idx1];
                                            if ((x % 2) == 0) {
                                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                    }

                    }
                    return ceto__private__ident__8;
                }([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(std::ranges::iota_view(0, 10))> ) && true) || ceto::IsStateless<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__9) {
        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__9)>>() } ;
        maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
        
    
            static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
            size_t ceto__private__size4 = std::size(ceto__private__ident__9);
            for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                if (std::size(ceto__private__ident__9) != ceto__private__size4) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx3 >= ceto__private__size4) {
                    break ;
                }
                const auto x = ceto__private__ident__9[ceto__private__idx3];
                            if ((x % 2) == 0) {
                        (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                    }

            }
            return ceto__private__ident__8;
        })>> )); return std::ranges::iota_view(0, 10); }());
        ceto::safe_for_loop<!std::is_reference_v<decltype(l)> && ceto::OwningContainer<std::remove_cvref_t<decltype(l)>>>(l, [&](auto &&ceto__private__lambda_param5) -> ceto::LoopControl {
    const auto x = ceto__private__lambda_param5;
            std::cout << x;
    return ceto::LoopControl::Continue;
});        const auto l2 = []( auto &&  ceto__private__ident__7) {
                auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()+1)>() } ;
                maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                
    
                    static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                    size_t ceto__private__size7 = std::size(ceto__private__ident__7);
                    for (size_t ceto__private__idx6 = 0; ; ceto__private__idx6++) {
                        if (std::size(ceto__private__ident__7) != ceto__private__size7) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx6 >= ceto__private__size7) {
                            break ;
                        }
                        const auto x = ceto__private__ident__7[ceto__private__idx6];
                                            (ceto__private__ident__6).push_back(x + 1);

                    }
                    return ceto__private__ident__6;
                }(l);
        ceto::safe_for_loop<!std::is_reference_v<decltype([]( auto &&  ceto__private__ident__11) {
                    auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__11)>>() } ;
                    maybe_reserve(ceto__private__ident__10, ceto__private__ident__11);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__11) + 2; }, "not a contiguous container");
                        size_t ceto__private__size9 = std::size(ceto__private__ident__11);
                        for (size_t ceto__private__idx8 = 0; ; ceto__private__idx8++) {
                            if (std::size(ceto__private__ident__11) != ceto__private__size9) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx8 >= ceto__private__size9) {
                                break ;
                            }
                            const auto x = ceto__private__ident__11[ceto__private__idx8];
                                                    if (x > 5) {
                                                (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                                            }

                        }
                        return ceto__private__ident__10;
                    }(l2))> && ceto::OwningContainer<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__11) {
                    auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__11)>>() } ;
                    maybe_reserve(ceto__private__ident__10, ceto__private__ident__11);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__11) + 2; }, "not a contiguous container");
                        size_t ceto__private__size9 = std::size(ceto__private__ident__11);
                        for (size_t ceto__private__idx8 = 0; ; ceto__private__idx8++) {
                            if (std::size(ceto__private__ident__11) != ceto__private__size9) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx8 >= ceto__private__size9) {
                                break ;
                            }
                            const auto x = ceto__private__ident__11[ceto__private__idx8];
                                                    if (x > 5) {
                                                (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                                            }

                        }
                        return ceto__private__ident__10;
                    }(l2))>>>([]( auto &&  ceto__private__ident__11) {
                    auto ceto__private__ident__10 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__11)>>() } ;
                    maybe_reserve(ceto__private__ident__10, ceto__private__ident__11);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__11) + 2; }, "not a contiguous container");
                        size_t ceto__private__size9 = std::size(ceto__private__ident__11);
                        for (size_t ceto__private__idx8 = 0; ; ceto__private__idx8++) {
                            if (std::size(ceto__private__ident__11) != ceto__private__size9) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx8 >= ceto__private__size9) {
                                break ;
                            }
                            const auto x = ceto__private__ident__11[ceto__private__idx8];
                                                    if (x > 5) {
                                                (ceto__private__ident__10).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__10)>>)); return x; }());
                                            }

                        }
                        return ceto__private__ident__10;
                    }(l2), [&](auto &&ceto__private__lambda_param10) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param10;
            std::cout << i;
    return ceto::LoopControl::Continue;
});        ceto::safe_for_loop<!std::is_reference_v<decltype([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()*100)>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size12 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx11 = 0; ; ceto__private__idx11++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size12) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx11 >= ceto__private__size12) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx11];
                                                    (ceto__private__ident__6).push_back(x * 100);

                        }
                        return ceto__private__ident__6;
                    }(l))> && ceto::OwningContainer<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()*100)>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size12 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx11 = 0; ; ceto__private__idx11++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size12) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx11 >= ceto__private__size12) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx11];
                                                    (ceto__private__ident__6).push_back(x * 100);

                        }
                        return ceto__private__ident__6;
                    }(l))>>>([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()*100)>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size12 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx11 = 0; ; ceto__private__idx11++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size12) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx11 >= ceto__private__size12) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx11];
                                                    (ceto__private__ident__6).push_back(x * 100);

                        }
                        return ceto__private__ident__6;
                    }(l), [&](auto &&ceto__private__lambda_param13) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param13;
            std::cout << i;
    return ceto::LoopControl::Continue;
});        ceto::safe_for_loop<!std::is_reference_v<decltype([&]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()+std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__9) {
                            auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__9)>>() } ;
                            maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
                            
    
                                static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
                                size_t ceto__private__size15 = std::size(ceto__private__ident__9);
                                for (size_t ceto__private__idx14 = 0; ; ceto__private__idx14++) {
                                    if (std::size(ceto__private__ident__9) != ceto__private__size15) {
                                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                        std::terminate();
                                    }
                                    if (ceto__private__idx14 >= ceto__private__size15) {
                                        break ;
                                    }
                                    const auto x = ceto__private__ident__9[ceto__private__idx14];
                                                                    if ((x % 2) == 0) {
                                                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                                            }

                                }
                                return ceto__private__ident__8;
                            }(std::declval<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>()))>>(), 0))>>())>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size17 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx16 = 0; ; ceto__private__idx16++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size17) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx16 >= ceto__private__size17) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx16];
                                                    (ceto__private__ident__6).push_back(x + ceto::bounds_check(l, 0));

                        }
                        return ceto__private__ident__6;
                    }(l))> && ceto::OwningContainer<std::remove_cvref_t<decltype([&]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()+std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__9) {
                            auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__9)>>() } ;
                            maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
                            
    
                                static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
                                size_t ceto__private__size15 = std::size(ceto__private__ident__9);
                                for (size_t ceto__private__idx14 = 0; ; ceto__private__idx14++) {
                                    if (std::size(ceto__private__ident__9) != ceto__private__size15) {
                                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                        std::terminate();
                                    }
                                    if (ceto__private__idx14 >= ceto__private__size15) {
                                        break ;
                                    }
                                    const auto x = ceto__private__ident__9[ceto__private__idx14];
                                                                    if ((x % 2) == 0) {
                                                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                                            }

                                }
                                return ceto__private__ident__8;
                            }(std::declval<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>()))>>(), 0))>>())>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size17 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx16 = 0; ; ceto__private__idx16++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size17) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx16 >= ceto__private__size17) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx16];
                                                    (ceto__private__ident__6).push_back(x + ceto::bounds_check(l, 0));

                        }
                        return ceto__private__ident__6;
                    }(l))>>>([&]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<decltype(std::declval<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>()+std::declval<std::remove_cvref_t<decltype(ceto::bounds_check(std::declval<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__9) {
                            auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__9)>>() } ;
                            maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
                            
    
                                static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
                                size_t ceto__private__size15 = std::size(ceto__private__ident__9);
                                for (size_t ceto__private__idx14 = 0; ; ceto__private__idx14++) {
                                    if (std::size(ceto__private__ident__9) != ceto__private__size15) {
                                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                        std::terminate();
                                    }
                                    if (ceto__private__idx14 >= ceto__private__size15) {
                                        break ;
                                    }
                                    const auto x = ceto__private__ident__9[ceto__private__idx14];
                                                                    if ((x % 2) == 0) {
                                                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                                            }

                                }
                                return ceto__private__ident__8;
                            }(std::declval<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>()))>>(), 0))>>())>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size17 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx16 = 0; ; ceto__private__idx16++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size17) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx16 >= ceto__private__size17) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx16];
                                                    (ceto__private__ident__6).push_back(x + ceto::bounds_check(l, 0));

                        }
                        return ceto__private__ident__6;
                    }(l), [&](auto &&ceto__private__lambda_param18) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param18;
            std::cout << i;
    return ceto::LoopControl::Continue;
});        const auto list_of_lists = std::vector {{std::vector {{1, 2, 3}}, std::vector {{2, 3, 4}}, std::vector {{3, 4, 5}}}};
        ceto::safe_for_loop<!std::is_reference_v<decltype([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size20 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx19 = 0; ; ceto__private__idx19++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size20) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx19 >= ceto__private__size20) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx19];
                                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                        }
                        return ceto__private__ident__6;
                    }([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(list_of_lists, 0))> ) && true) || ceto::IsStateless<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__7) {
            auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
            maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
            
    
                static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                size_t ceto__private__size22 = std::size(ceto__private__ident__7);
                for (size_t ceto__private__idx21 = 0; ; ceto__private__idx21++) {
                    if (std::size(ceto__private__ident__7) != ceto__private__size22) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx21 >= ceto__private__size22) {
                        break ;
                    }
                    const auto x = ceto__private__ident__7[ceto__private__idx21];
                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                }
                return ceto__private__ident__6;
            })>> )); return ceto::bounds_check(list_of_lists, 0); }()))> && ceto::OwningContainer<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size20 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx19 = 0; ; ceto__private__idx19++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size20) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx19 >= ceto__private__size20) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx19];
                                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                        }
                        return ceto__private__ident__6;
                    }([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(list_of_lists, 0))> ) && true) || ceto::IsStateless<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__7) {
            auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
            maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
            
    
                static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                size_t ceto__private__size22 = std::size(ceto__private__ident__7);
                for (size_t ceto__private__idx21 = 0; ; ceto__private__idx21++) {
                    if (std::size(ceto__private__ident__7) != ceto__private__size22) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx21 >= ceto__private__size22) {
                        break ;
                    }
                    const auto x = ceto__private__ident__7[ceto__private__idx21];
                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                }
                return ceto__private__ident__6;
            })>> )); return ceto::bounds_check(list_of_lists, 0); }()))>>>([]( auto &&  ceto__private__ident__7) {
                    auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
                    maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                    
    
                        static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                        size_t ceto__private__size20 = std::size(ceto__private__ident__7);
                        for (size_t ceto__private__idx19 = 0; ; ceto__private__idx19++) {
                            if (std::size(ceto__private__ident__7) != ceto__private__size20) {
                                std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                std::terminate();
                            }
                            if (ceto__private__idx19 >= ceto__private__size20) {
                                break ;
                            }
                            const auto x = ceto__private__ident__7[ceto__private__idx19];
                                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                        }
                        return ceto__private__ident__6;
                    }([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(ceto::bounds_check(list_of_lists, 0))> ) && true) || ceto::IsStateless<std::remove_cvref_t<decltype([]( auto &&  ceto__private__ident__7) {
            auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<decltype(ceto__private__ident__7)>>() } ;
            maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
            
    
                static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                size_t ceto__private__size22 = std::size(ceto__private__ident__7);
                for (size_t ceto__private__idx21 = 0; ; ceto__private__idx21++) {
                    if (std::size(ceto__private__ident__7) != ceto__private__size22) {
                        std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                        std::terminate();
                    }
                    if (ceto__private__idx21 >= ceto__private__size22) {
                        break ;
                    }
                    const auto x = ceto__private__ident__7[ceto__private__idx21];
                                    (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert((((!std::is_reference_v<decltype(x)> ) && true)  || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());

                }
                return ceto__private__ident__6;
            })>> )); return ceto::bounds_check(list_of_lists, 0); }()), [&](auto &&ceto__private__lambda_param23) -> ceto::LoopControl {
    const auto i = ceto__private__lambda_param23;
            std::cout << i;
    return ceto::LoopControl::Continue;
});    }

