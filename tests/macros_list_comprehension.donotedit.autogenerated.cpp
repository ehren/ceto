
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
#include <ranges>
;

;

;

;
#include "macros_list_comprehension.donotedit.autogenerated.h"
;
    auto main() -> int {
        const auto l = [&]() {
                auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                auto && ceto__private__ident__7 { std::ranges::iota_view(0, 10) } ;
                maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                
    
                    static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                    size_t ceto__private__size2 = std::size(ceto__private__ident__7);
                    for (size_t ceto__private__idx1 = 0; ; ceto__private__idx1++) {
                        if (std::size(ceto__private__ident__7) != ceto__private__size2) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx1 >= ceto__private__size2) {
                            break;
                        }
                        const auto x = ceto__private__ident__7[ceto__private__idx1];
                                            if ((x % 2) == 0) {
                                        (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());
                                    }

                    }
                    return ceto__private__ident__6;
                }();
        
    
            static_assert(requires { std::begin(l) + 2; }, "not a contiguous container");
            size_t ceto__private__size4 = std::size(l);
            for (size_t ceto__private__idx3 = 0; ; ceto__private__idx3++) {
                if (std::size(l) != ceto__private__size4) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx3 >= ceto__private__size4) {
                    break;
                }
                const auto x = l[ceto__private__idx3];
                            std::cout << x;

            }
            const auto l2 = [&]() {
                auto ceto__private__ident__4 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                        auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                        auto && ceto__private__ident__7 { std::ranges::iota_view(0, 10) } ;
                        maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                        
    
                            static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                            size_t ceto__private__size6 = std::size(ceto__private__ident__7);
                            for (size_t ceto__private__idx5 = 0; ; ceto__private__idx5++) {
                                if (std::size(ceto__private__ident__7) != ceto__private__size6) {
                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                    std::terminate();
                                }
                                if (ceto__private__idx5 >= ceto__private__size6) {
                                    break;
                                }
                                const auto x = ceto__private__ident__7[ceto__private__idx5];
                                                            if ((x % 2) == 0) {
                                                        (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());
                                                    }

                            }
                            return ceto__private__ident__6;
                        }())>>>()+1)>() } ;
                auto && ceto__private__ident__5 { l } ;
                maybe_reserve(ceto__private__ident__4, ceto__private__ident__5);
                
    
                    static_assert(requires { std::begin(ceto__private__ident__5) + 2; }, "not a contiguous container");
                    size_t ceto__private__size8 = std::size(ceto__private__ident__5);
                    for (size_t ceto__private__idx7 = 0; ; ceto__private__idx7++) {
                        if (std::size(ceto__private__ident__5) != ceto__private__size8) {
                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                            std::terminate();
                        }
                        if (ceto__private__idx7 >= ceto__private__size8) {
                            break;
                        }
                        const auto x = ceto__private__ident__5[ceto__private__idx7];
                                            (ceto__private__ident__4).push_back(x + 1);

                    }
                    return ceto__private__ident__4;
                }();
        
            auto&& ceto__private__intermediate9 = [&]() {
                        auto ceto__private__ident__8 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                auto ceto__private__ident__4 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                        auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                                        auto && ceto__private__ident__7 { std::ranges::iota_view(0, 10) } ;
                                        maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                                
    
                                            static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                                            size_t ceto__private__size11 = std::size(ceto__private__ident__7);
                                            for (size_t ceto__private__idx10 = 0; ; ceto__private__idx10++) {
                                                if (std::size(ceto__private__ident__7) != ceto__private__size11) {
                                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                                    std::terminate();
                                                }
                                                if (ceto__private__idx10 >= ceto__private__size11) {
                                                    break;
                                                }
                                                const auto x = ceto__private__ident__7[ceto__private__idx10];
                                                                                    if ((x % 2) == 0) {
                                                                                (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());
                                                                            }

                                            }
                                            return ceto__private__ident__6;
                                        }())>>>()+1)>() } ;
                                auto && ceto__private__ident__5 { l } ;
                                maybe_reserve(ceto__private__ident__4, ceto__private__ident__5);
                        
    
                                    static_assert(requires { std::begin(ceto__private__ident__5) + 2; }, "not a contiguous container");
                                    size_t ceto__private__size13 = std::size(ceto__private__ident__5);
                                    for (size_t ceto__private__idx12 = 0; ; ceto__private__idx12++) {
                                        if (std::size(ceto__private__ident__5) != ceto__private__size13) {
                                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                            std::terminate();
                                        }
                                        if (ceto__private__idx12 >= ceto__private__size13) {
                                            break;
                                        }
                                        const auto x = ceto__private__ident__5[ceto__private__idx12];
                                                                    (ceto__private__ident__4).push_back(x + 1);

                                    }
                                    return ceto__private__ident__4;
                                }())>>>() } ;
                        auto && ceto__private__ident__9 { l2 } ;
                        maybe_reserve(ceto__private__ident__8, ceto__private__ident__9);
                
    
                            static_assert(requires { std::begin(ceto__private__ident__9) + 2; }, "not a contiguous container");
                            size_t ceto__private__size15 = std::size(ceto__private__ident__9);
                            for (size_t ceto__private__idx14 = 0; ; ceto__private__idx14++) {
                                if (std::size(ceto__private__ident__9) != ceto__private__size15) {
                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                    std::terminate();
                                }
                                if (ceto__private__idx14 >= ceto__private__size15) {
                                    break;
                                }
                                const auto x = ceto__private__ident__9[ceto__private__idx14];
                                                    if (x > 5) {
                                                (ceto__private__ident__8).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__8)>>)); return x; }());
                                            }

                            }
                            return ceto__private__ident__8;
                        }();

            static_assert(requires { std::begin(ceto__private__intermediate9) + 2; }, "not a contiguous container");
            size_t ceto__private__size17 = std::size(ceto__private__intermediate9);
            for (size_t ceto__private__idx16 = 0; ; ceto__private__idx16++) {
                if (std::size(ceto__private__intermediate9) != ceto__private__size17) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx16 >= ceto__private__size17) {
                    break;
                }
                const auto i = ceto__private__intermediate9[ceto__private__idx16];
                            std::cout << i;

            }
            
            auto&& ceto__private__intermediate18 = [&]() {
                        auto ceto__private__ident__4 { std::vector<decltype(std::declval<std::ranges::range_value_t<std::remove_cvref_t<decltype([&]() {
                                auto ceto__private__ident__6 { std::vector<std::ranges::range_value_t<std::remove_cvref_t<decltype(std::ranges::iota_view(0, 10))>>>() } ;
                                auto && ceto__private__ident__7 { std::ranges::iota_view(0, 10) } ;
                                maybe_reserve(ceto__private__ident__6, ceto__private__ident__7);
                        
    
                                    static_assert(requires { std::begin(ceto__private__ident__7) + 2; }, "not a contiguous container");
                                    size_t ceto__private__size20 = std::size(ceto__private__ident__7);
                                    for (size_t ceto__private__idx19 = 0; ; ceto__private__idx19++) {
                                        if (std::size(ceto__private__ident__7) != ceto__private__size20) {
                                            std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                            std::terminate();
                                        }
                                        if (ceto__private__idx19 >= ceto__private__size20) {
                                            break;
                                        }
                                        const auto x = ceto__private__ident__7[ceto__private__idx19];
                                                                    if ((x % 2) == 0) {
                                                                (ceto__private__ident__6).push_back([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(x)> ) && true || ceto::IsContainer<std::remove_cvref_t<decltype(ceto__private__ident__6)>>)); return x; }());
                                                            }

                                    }
                                    return ceto__private__ident__6;
                                }())>>>()*100)>() } ;
                        auto && ceto__private__ident__5 { l } ;
                        maybe_reserve(ceto__private__ident__4, ceto__private__ident__5);
                
    
                            static_assert(requires { std::begin(ceto__private__ident__5) + 2; }, "not a contiguous container");
                            size_t ceto__private__size22 = std::size(ceto__private__ident__5);
                            for (size_t ceto__private__idx21 = 0; ; ceto__private__idx21++) {
                                if (std::size(ceto__private__ident__5) != ceto__private__size22) {
                                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                                    std::terminate();
                                }
                                if (ceto__private__idx21 >= ceto__private__size22) {
                                    break;
                                }
                                const auto x = ceto__private__ident__5[ceto__private__idx21];
                                                    (ceto__private__ident__4).push_back(x * 100);

                            }
                            return ceto__private__ident__4;
                        }();

            static_assert(requires { std::begin(ceto__private__intermediate18) + 2; }, "not a contiguous container");
            size_t ceto__private__size24 = std::size(ceto__private__intermediate18);
            for (size_t ceto__private__idx23 = 0; ; ceto__private__idx23++) {
                if (std::size(ceto__private__intermediate18) != ceto__private__size24) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx23 >= ceto__private__size24) {
                    break;
                }
                const auto i = ceto__private__intermediate18[ceto__private__idx23];
                            std::cout << i;

            }
        }

