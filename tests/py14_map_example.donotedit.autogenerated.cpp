
#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <sstream>
#include <functional>
#include <cassert>
#include <compare> // for <=>
#include <thread>
#include <optional>


#include "ceto.h"


;

;

;

;

;

;

;

;

;

;

;
#include "ceto_private_listcomp.donotedit.autogenerated.h"
;
#include "ceto_private_boundscheck.donotedit.autogenerated.h"
;
#include "ceto_private_convenience.donotedit.autogenerated.h"
;
#include "ceto_private_append_to_pushback.donotedit.autogenerated.h"
;
    template <typename T1, typename T2>
auto map(const T1& values, const T2& fun) -> auto {
        auto results { std::vector<std::remove_cvref_t<decltype(fun(std::declval<std::ranges::range_value_t<decltype(values)>>()))>>() } ;
        
    
            static_assert(requires { std::begin(values) + 2; }, "not a contiguous container");
            size_t ceto__private__size2 = std::size(values);
            for (size_t ceto__private__idx1 = 0; ; ceto__private__idx1++) {
                if (std::size(values) != ceto__private__size2) {
                    std::cerr << "Container size changed during iteration: " << __FILE__ << " line: "<< __LINE__ << "\n";
                    std::terminate();
                }
                if (ceto__private__idx1 >= ceto__private__size2) {
                    break;
                }
                const auto v = values[ceto__private__idx1];
                            (results).push_back(fun([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(v)> ) && ceto::IsStateless<std::remove_cvref_t<decltype(fun)>> || ceto::IsContainer<std::remove_cvref_t<decltype(results)>>)); return v; }()));

            }
            return results;
    }

    inline auto foo(const int  x) -> auto {
        std::cout << x;
        return x;
    }

    template <typename T1>
auto foo_generic(const T1& x) -> auto {
        std::cout << x;
        return x;
    }

    auto main() -> int {
        const auto l = std::vector {{1, 2, 3, 4}};
        map([&]() -> decltype(auto) { static_assert(((!std::is_reference_v<decltype(map(l, [](const auto &x) {
                std::cout << x;
                return (x * 2);
                }))>  || (!std::is_reference_v<decltype([](const auto &x) {
                std::cout << x;
                return x;
                })> && std::is_fundamental_v<std::remove_cvref_t<decltype([](const auto &x) {
                std::cout << x;
                return x;
                })>>)) && true)); return map(l, [](const auto &x) {
                std::cout << x;
                return (x * 2);
                }); }(), [](const auto &x) {
                std::cout << x;
                return x;
                });
        map(l, foo);
        map(l, [](const int  x) {
                return foo_generic(x);
                });
        map(l, [](const auto &x) {
                return foo_generic(x);
                });
        map(l, foo_generic<int>);
    }

