# def (foo<T> -> def (foo:template<typename:T>
defmacro(def (func_name<T>:specifier, args), func_name, T: Identifier, specifier: Node|None, args: [Node]:
    template_header: Node = quote(template<typename:unquote(T)>)
    specified_template = if (specifier:
        specified: Node = quote(unquote(template_header):unquote(specifier))
        specified
    else:
        template_header
    )
    new_args: mut:[Node] = [quote(unquote(func_name):unquote(specified_template))]
    unsafe (:
        new_args.insert(new_args.end(), args.begin(), args.end())
    )
    return Call(quote(def), new_args)
)

# canonical empty destructor to default destructor:
# e.g.
# def (destruct:virtual:
#     pass
# )
# goes to
# def (destruct:virtual) = default
# For an empty non-default destructor
# use pass; pass
defmacro (def (destruct:specifier:
    pass
), specifier: Node|None:
    name: Node = quote(destruct)
    destructor = if (specifier:
        specified: Node = quote(unquote(name): unquote(specifier))
        specified
    else:
        name
    )
    return quote(def (unquote(destructor)) = default)
)

# note codegen.py contains checks to prevent using { } as an anonymous scope
defmacro(scope (:
    stmts
), stmts: [Node]:
    block = Block(stmts)
    # Note that codegen currently doesn't allow constexpr-if to be an
    # if-expression. We should consider changing this (and TODO make
    # if (...) : noexpression for the "I don't want an expression-if case")
    return quote(if (1, unquote(block)): constexpr)
)

defmacro (None.type, type:
    return quote((lambda(:
        return None
    ): unquote(type)) ())
)

# works around some limitations of CTAD with map e.g.
# https://stackoverflow.com/questions/56104324/does-class-template-argument-deduction-works-with-stdmap
defmacro(m: west_specifier:std.map:east_specifier = {keyvals}, keyvals: [TypeOp],
         m: Identifier, map: Identifier, west_specifier: Node|None, east_specifier: Node|None:

    if (map.name() != "map" and map.name() != "unordered_map":
        return None
    )

    args: mut:[Node] = []
    keys: mut:[Node] = []

    vacuous: Node = quote(True)
    assertion: mut = vacuous
    map_type: mut = None.Node
    # ^ Note that we can't write mut:Node/Node:mut on the left (assertion and
    # map_type must be mut vars holding instances of Node aka Node:const aka const:Node)

    for (kv in keyvals:
        type = quote(std.(unquote(map))<decltype(unquote(kv.args.at(0))), decltype(unquote(kv.args.at(1)))>)
        if (not map_type:
            map_type = type
        else:
            assertion = quote(unquote(assertion) and std.is_same_v<unquote(type), unquote(map_type)>)
        )
        args.append(quote({unquote(kv.args.at(0)), unquote(kv.args.at(1))}))
        keys.append(kv.args.at(0))
    )

    comparator = lambda(a, b, a.equals(b))
    unsafe (:
        duplicate_iter = std.adjacent_find(keys.cbegin(), keys.cend(), comparator)
        if (duplicate_iter != keys.cend():
            # note there are cases where duplicate keys slip past e.g. { 1 - 1: "zero", 0: "zero"}
            throw (std.runtime_error("duplicate keys in map literal"))
        )
    )

    map_call = BracedCall(map_type, args)

    if (west_specifier:
        map_type = quote(unquote(west_specifier): unquote(map_type))
    )

    if (east_specifier:
        map_type = quote(unquote(map_type): unquote(east_specifier))
    )

    return quote(unquote(m): unquote(map_type) = lambda(:
        static_assert(unquote(assertion), "all key-value pairs must be of the same type in map literal")
        unquote(map_call)
    ) ())
)

#defmacro(decltype(foo).bar, foo, bar:
#    # codegen has enough complication w/ implicit scope resolution as is (plus decltype)
#    # one case fewer to worry about:
#    return quote(decltype(unquote(foo))::unquote(bar))
#)

namespace(ceto.util:
    # TODO needs the syntax suggestion in boundscheck.cth
    cpp'
    template <template <class...> class T_container>
    struct to {
    };'

    # c z: https://stackoverflow.com/a/79612294/1391250
    # template <template <class...> class T_container, std::ranges::range T_range>
    # auto operator|(T_range&& r, to<T_container>) {
    #     using value_type = typename decltype(r.begin())::value_type;
    #     return T_container<value_type>{r.begin(), r.end()};
    # }

    cpp(std.ranges.range,
        to, T_container  # TODO won't be necessary once 'to' is a ceto struct
    )

    def (operator("|"): template <template <class...>:class:T_container, std.ranges.range:T_range>,
         r: mut:T_range:ref:ref, 
         t: to<T_container>:

        static_cast<void>(t)  # unused (TODO _: type for param decl without variable name)
        value_type: using = typename : decltype(r.begin())::value_type
        return T_container<value_type>{unsafe(r.begin()), unsafe(r.end())}
    )
)

defmacro (view | [], view:
    if (__cplusplus >= 202302L:
        return quote(unquote(view) | std.ranges.to<std.vector>())
    else:
        return quote(unquote(view) | ceto.util.to<std.vector>())
    ): preprocessor
)

defmacro (isinstance(x, (Foos,)), x, Foos: [Node]:
    cpp (std.views)

    if (Foos.size() == 0:
        throw (std.runtime_error("empty isinstance list:" + x.parent().repr()))
    )
    
    or_expr: mut = quote(isinstance(unquote(x), unquote(Foos.at(0))))
    
    for (foo in Foos | std.views.drop(1) | []:
        or_expr = quote(unquote(or_expr) or isinstance(unquote(x), unquote(foo)))
    )

    return or_expr
)

defmacro (isinstance(x, Foo) and expr, x: Identifier, Foo, expr:
    x_as_foo: Node = gensym()
    class (State:
        did_replace = False
    )
    state: mut = State()
    new_expr = expr.replace(lambda (orig:
        if (orig.name() != x.name():
            return None.Node
        )
        parent: mut = orig.parent()
        ignore: mut = False
        while (parent:
            if (isinstance(parent, Call):
                func = parent.func
                name = func.name()
                if (name:
                    name_val = name.value()
                    # if this were implemented in the backend we could check if x and the replaced x have the same VariableDefinition
                    # (TODO scope / lookup table support for macros)
                    if (ceto.util.contains(["isinstance"s, "asinstance"s, "lambda"s, "class"s, "struct"s], name_val):
                        ignore = True
                        break
                    )
                elif func.equals(quote(lambda[])):
                    ignore = True
                    break
                )
            elif (attr = asinstance(parent, BinOp)):
                if (isinstance(attr, (AttributeAccess, ScopeResolution, ArrowOp)) and orig.equals(attr.rhs()):
                    ignore = True
                    break
                )
            )
            parent = parent.parent()
        )
        if (ignore:
            return None.Node
        )
        capture: mut = state
        capture.did_replace = True
        return x_as_foo
    ))

    if (not state.did_replace:
        return None
    )

    return quote(lambda(:
        unquote(x_as_foo) = asinstance(unquote(x), unquote(Foo))
        if (not unquote(x_as_foo):
            return False
        )
        return True and unquote(new_expr)
    )())
)

cpp'
#define CETO_ENABLE_PRINTF_DEBUGGING
'

# printf debugging
#defmacro(node, node:
#    enable: mut:static:bool = False
#
#    # TODO should take source loc or at least file into account (which will also allow logging in lambda bodies)
#    already_processed: mut:static:std.unordered_map<std.string, bool> = {}  # use a map to avoid include<set> in all programs
#
#    if (not enable:
#        if (node.equals(quote(ceto.enable_printf_debugging())):
#            enable = True
#            return quote(pass)
#        )
#    )
#
#    if (isinstance(node, Call) and node.args.size() > 0 and node.func.name() == "def":
#        type_of_name: mut = node.args.at(0)
#        name = type_of_name.args.at(0).repr()
#        if (name.starts_with("macro_impl"):
#            # macro matching runs on the generated function implementing the macro when the DLL is compiled including for the current macro leading to very confusing compile-time output
#            # (it also runs on the defmacro Call even when it's not being compiled to DLL but that's not a match)
#            return None  # just filter all macro implementations
#        elif name == "init":
#            # we don't want to insert lines in constructors (interferes w/ implicit initializer list because non-initialization statements appear first)
#            return None
#        )
#
#        class (State:
#            local_enable: bool = False
#        )
#        state: mut = State()
#        type_of_name = type_of_name.replace(lambda(orig: 
#            if (orig.equals(quote(ceto.enable_printf_debugging)) or orig.equals(quote(CETO_ENABLE_PRINTF_DEBUGGING)): 
#                capture: mut = state
#                capture.local_enable = True
#                quote(CETO_ENABLE_PRINTF_DEBUGGING) 
#            else: 
#                None.Node
#            )
#        ))
#
##        while (isinstance(type_of_name, TypeOp):
##            if (type_of_name.args.at(0).equals(ceto.enable_printf_debugging):
##                type_of_name.args.at(0) = quote(CETO_PRIVATE_NOTHING)
##                local_enable = True
##            )
##            type_of_name = type_of_name.args.at(1)
##        )
#        if (not enable or state.local_enable:
#            return None
#        )
#
#        args: mut = node.args
#        block = args.back()
#        if (not isinstance(block, Block):
#            return None  # forward declaration
#        )
#        args.pop_back()
#        args.at(0) = type_of_name
#        defrepr = Call(node.func, args).repr()
#        if (already_processed.at(defrepr):
#            return None
#        )
#        already_processed.at(defrepr) = True
#        
#        new_args: mut:[Node] = []
#        for (arg in block.args:
#            string_lit = StringLiteral(arg.repr())
#            new_args.push_back(quote(std.cout << "running: " << unquote(string_lit) << "\n"))
#            new_args.push_back(arg)
#        )
#        new_block = Block(new_args)
#        args.push_back(new_block)
#        return Call(node.func, args)
#    )
#
#    return None
#)


# just for testing out performance consequences of safe for loops in selfhost (not too significant)
#defmacro (for(x:T in iterable, block), x, T: Node|None, iterable, block: Block:
#    t = if (T:
#        T
#    else:
#        full: Node = quote(const:auto:ref)
#        full
#    )
#
#    in_expr = quote(unquote(x): unquote(t) in unquote(iterable))
#
#    args: [Node] = [in_expr, block]
#
#    return Call(quote(unsafe_for), args)
#)

#defmacro (vec[index], vec, index:
#    if (vec.name() == "lambda":
#        return None
#    )
#
#    return quote(unquote(vec).unsafe[unquote(index)])
#)
