include <set>

# def (foo<T> -> def (foo:template<typename:T>
defmacro(def (func_name<T>:specifier, args), func_name, T: Identifier, specifier: Node|None, args: [Node]:
    template_header: Node = quote(template<typename:unquote(T)>)
    specified_template = if (specifier:
        specified: Node = quote(unquote(template_header):unquote(specifier))
        specified
    else:
        template_header
    )
    new_args: mut:[Node] = [quote(unquote(func_name):unquote(specified_template))]
    unsafe (:
        new_args.insert(new_args.end(), args.begin(), args.end())
    )
    return Call(quote(def), new_args)
)

# canonical empty destructor to default destructor:
# e.g.
# def (destruct:virtual:
#     pass
# )
# goes to
# def (destruct:virtual) = default
# For an empty non-default destructor
# use pass; pass
defmacro (def (destruct:specifier:
    pass
), specifier: Node|None:
    name: Node = quote(destruct)
    destructor = if (specifier:
        specified: Node = quote(unquote(name): unquote(specifier))
        specified
    else:
        name
    )
    return quote(def (unquote(destructor)) = default)
)

# note codegen.py contains checks to prevent using { } as an anonymous scope
defmacro(scope (:
    stmts
), stmts: [Node]:
    block = Block(stmts)
    # Note that codegen currently doesn't allow constexpr-if to be an
    # if-expression. We should consider changing this (and TODO make
    # if (...) : noexpression for the "I don't want an expression-if case")
    return quote(if (1, unquote(block)): constexpr)
)

defmacro (None.type, type:
    return quote((lambda(:
        return None
    ): unquote(type)) ())
)

# works around some limitations of CTAD with map e.g.
# https://stackoverflow.com/questions/56104324/does-class-template-argument-deduction-works-with-stdmap
defmacro(m: west_specifier:std.map:east_specifier = {keyvals}, keyvals: [TypeOp],
         m: Identifier, map: Identifier, west_specifier: Node|None, east_specifier: Node|None:

    if (map.name() != "map" and map.name() != "unordered_map":
        return None
    )

    args: mut:[Node] = []
    keys: mut:[Node] = []

    vacuous: Node = quote(True)
    assertion: mut = vacuous
    map_type: mut = None.Node
    # ^ Note that we can't write mut:Node/Node:mut on the left (assertion and
    # map_type must be mut vars holding instances of Node aka Node:const aka const:Node)

    for (kv in keyvals:
        type = quote(std.(unquote(map))<decltype(unquote(kv.args.at(0))), decltype(unquote(kv.args.at(1)))>)
        if (not map_type:
            map_type = type
        else:
            assertion = quote(unquote(assertion) and std.is_same_v<unquote(type), unquote(map_type)>)
        )
        args.append(quote({unquote(kv.args.at(0)), unquote(kv.args.at(1))}))
        keys.append(kv.args.at(0))
    )

    comparator = lambda(a, b, a.equals(b))
    unsafe (:
        duplicate_iter = std.adjacent_find(keys.cbegin(), keys.cend(), comparator)
        if (duplicate_iter != keys.cend():
            # note there are cases where duplicate keys slip past e.g. { 1 - 1: "zero", 0: "zero"}
            throw (std.runtime_error("duplicate keys in map literal"))
        )
    )

    map_call = BracedCall(map_type, args)

    if (west_specifier:
        map_type = quote(unquote(west_specifier): unquote(map_type))
    )

    if (east_specifier:
        map_type = quote(unquote(map_type): unquote(east_specifier))
    )

    return quote(unquote(m): unquote(map_type) = lambda(:
        static_assert(unquote(assertion), "all key-value pairs must be of the same type in map literal")
        unquote(map_call)
    ) ())
)

defmacro (isinstance(x, Foo) and expr, x, Foo, expr:
    x_as_Foo: Node = gensym()
    class (State:
        did_replace = False
    )
    state: mut = State()
    x_is_ident = isinstance(x, Identifier)
    new_expr = expr.replace(lambda (orig:
        if (not orig.equals(x):
            return None.Node
        )
        parent: mut = orig.parent()
        ignore: mut = False
        while (parent:
            if (isinstance(parent, Call):
                func = parent.func
                name = func.name()
                if (name:
                    name_val = name.value()
                    if (ceto.util.contains(["isinstance"s, "asinstance"s, "lambda"s, "class"s, "struct"s], name_val):
                        ignore = True
                        break
                    )
                elif func.equals(quote(lambda[])):
                    ignore = True
                    break
                )
            elif (attr = asinstance(parent, BinOp)):
                if (not (isinstance(attr, AttributeAccess) or isinstance(attr, ScopeResolution) or isinstance(attr, ArrowOp)):
                    pass
                elif orig.equals(attr.rhs()):
                    ignore = True
                    break
                )
            )
            parent = parent.parent()
        )
        if (ignore:
            return None.Node
        )
        capture: mut = state
        capture.did_replace = True
        if (x_is_ident:
            return x_as_Foo
        )
        return quote(asinstance(unquote(x), unquote(Foo)))
    ))
    if (not state.did_replace:
        return None
    )
    if (x_is_ident:
        return quote(lambda(:
            unquote(x_as_Foo) = asinstance(unquote(x), unquote(Foo))
            if (not unquote(x_as_Foo):
                return False
            )
            return True and unquote(new_expr)
        )())
    else:
        return quote(asinstance(unquote(x), unquote(Foo)) != None and unquote(new_expr))
    )
)

cpp'
#define CETO_ENABLE_PRINTF_DEBUGGING
'

# printf debugging
#defmacro(node, node:
#    enable: mut:static:bool = False
#
#    # TODO should take source loc or at least file into account (which will also allow logging in lambda bodies)
#    already_processed: mut:static:std.set<std.string> = {}
#
#    if (not enable:
#        if (node.equals(quote(ceto.enable_printf_debugging())):
#            enable = True
#            return quote(pass)
#        )
#    )
#
#    if (isinstance(node, Call) and node.args.size() > 0 and node.func.name() == "def":
#        type_of_name: mut = node.args.at(0)
#        name = type_of_name.args.at(0).repr()
#        if (name.starts_with("macro_impl"):
#            # macro matching runs on the generated function implementing the macro when the DLL is compiled including for the current macro leading to very confusing compile-time output
#            # (it also runs on the defmacro Call even when it's not being compiled to DLL but that's not a match)
#            return None  # just filter all macro implementations
#        elif name == "init":
#            # we don't want to insert lines in constructors (interferes w/ implicit initializer list because non-initialization statements appear first)
#            return None
#        )
#
#        class (State:
#            local_enable: bool = False
#        )
#        state: mut = State()
#        type_of_name = type_of_name.replace(lambda(orig: 
#            if (orig.equals(quote(ceto.enable_printf_debugging)) or orig.equals(quote(CETO_ENABLE_PRINTF_DEBUGGING)): 
#                capture: mut = state
#                capture.local_enable = True
#                quote(CETO_ENABLE_PRINTF_DEBUGGING) 
#            else: 
#                None.Node
#            )
#        ))
#
##        while (isinstance(type_of_name, TypeOp):
##            if (type_of_name.args.at(0).equals(ceto.enable_printf_debugging):
##                type_of_name.args.at(0) = quote(CETO_PRIVATE_NOTHING)
##                local_enable = True
##            )
##            type_of_name = type_of_name.args.at(1)
##        )
#        if (not enable or state.local_enable:
#            return None
#        )
#
#        args: mut = node.args
#        block = args.back()
#        if (not isinstance(block, Block):
#            return None  # forward declaration
#        )
#        args.pop_back()
#        args.at(0) = type_of_name
#        defrepr = Call(node.func, args).repr()
#        if (already_processed.contains(defrepr):
#            return None
#        )
#        already_processed.insert(defrepr)
#        
#        new_args: mut:[Node] = []
#        for (arg in block.args:
#            string_lit = StringLiteral(arg.repr())
#            new_args.push_back(quote(std.cout << "running: " << unquote(string_lit) << "\n"))
#            new_args.push_back(arg)
#        )
#        new_block = Block(new_args)
#        args.push_back(new_block)
#        return Call(node.func, args)
#    )
#
#    return None
#)


# just for testing out performance consequences of safe for loops in selfhost (not too significant)
#defmacro (for(x:T in iterable, block), x, T: Node|None, iterable, block: Block:
#    t = if (T:
#        T
#    else:
#        full: Node = quote(const:auto:ref)
#        full
#    )
#
#    in_expr = quote(unquote(x): unquote(t) in unquote(iterable))
#
#    args: [Node] = [in_expr, block]
#
#    return Call(quote(unsafe_for), args)
#)

#defmacro (vec[index], vec, index:
#    if (vec.name() == "lambda":
#        return None
#    )
#
#    return quote(unquote(vec).unsafe[unquote(index)])
#)
