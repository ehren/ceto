include <ranges>

defmacro ([expr, for (i in iterable), if (cond)], expr, i, iterable, cond:
    result = gensym()
    iterable_param = gensym()

    pre_reserve_stmt = if (isinstance(cond, EqualsCompareOp) and std.ranges.any_of(
                           cond.args, lambda(a, a.equals(expr) or a.equals(i))):
        # Don't bother pre-reserving a std.size(z) sized vector for simple searches
        # e.g. [x, for (y in z), if (y == something)]
        dont_reserve: Node = quote(pass)
        dont_reserve
    else:
        reserve: Node = quote(ceto.util.maybe_reserve(unquote(result), unquote(iterable_param)))
        reserve
    )

    return quote(lambda (unquote(iterable_param): mut:auto:ref:ref:
        unquote(result): mut = []
        unquote(pre_reserve_stmt)

        for (unquote(i) in unquote(iterable_param):
            unquote(if (cond.name() == "True":
                # Omit literal if (True) check (reduce clutter for 2-arg case below)
                quote(unquote(result).append(unquote(expr)))
            else:
                quote(if (unquote(cond):
                    unquote(result).append(unquote(expr))
                ))
            ))
        )

        unquote(result)
    ) (unquote(iterable)))
)

defmacro ([expr, for (i in iterable)], expr, i, iterable:
    # Use the existing 3-arg definition
    return quote([unquote(expr), for (unquote(i) in unquote(iterable)), if (True)])
)

namespace(ceto.util)

def (maybe_reserve: template<typename:T>,
               vec: mut:[T]:ref,
             sized: mut:auto:ref:ref:
    unsafe.extern(std.forward)
    vec.reserve(std.size(std.forward<decltype(sized)>(sized)))
) : void:requires:requires(std.size(sized))

def (maybe_reserve: template<typename:T>,
               vec: mut:[T]:ref,
           unsized: mut:auto:ref:ref:
    pass
) : void:requires:not requires(std.size(unsized))
